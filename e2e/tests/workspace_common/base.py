"""Shared base helpers for workspace E2E tests."""

from __future__ import annotations

import json
import os
import time
import urllib.error
import urllib.request
from datetime import datetime, timezone
from typing import Any

from .console import print_warning


class WorkspaceE2EBase:
    """Reusable base class for workspace E2E tests.

    Provides:
    - HTTP requests with optional trusted header auth
    - session lifecycle helpers
    - tool invocation tracking
    - evidence recording and emission
    """

    def __init__(
        self,
        *,
        test_id: str,
        run_id_prefix: str,
        workspace_url: str,
        evidence_file: str,
    ) -> None:
        self.test_id = test_id
        self.workspace_url = workspace_url.rstrip("/")
        self.evidence_file = evidence_file
        self.run_id = f"{run_id_prefix}-{int(time.time())}"

        self.sessions: list[str] = []
        self.invocation_counter = 0

        self.evidence: dict[str, Any] = {
            "test_id": self.test_id,
            "run_id": self.run_id,
            "status": "running",
            "started_at": self.now_iso(),
            "workspace_url": self.workspace_url,
            "steps": [],
            "sessions": [],
            "invocations": [],
        }

    @staticmethod
    def now_iso() -> str:
        return datetime.now(timezone.utc).isoformat()

    def request(
        self,
        method: str,
        path: str,
        payload: dict[str, Any] | None = None,
        timeout: int = 60,
    ) -> tuple[int, dict[str, Any]]:
        url = self.workspace_url + path
        data = None
        headers = {"Content-Type": "application/json"}
        auth_token = os.getenv("WORKSPACE_AUTH_TOKEN", "").strip()
        if auth_token:
            headers.update(
                {
                    os.getenv("WORKSPACE_AUTH_TOKEN_HEADER", "X-Workspace-Auth-Token"): auth_token,
                    os.getenv("WORKSPACE_AUTH_TENANT_HEADER", "X-Workspace-Tenant-Id"): os.getenv(
                        "WORKSPACE_AUTH_TENANT_ID", "e2e-tenant"
                    ),
                    os.getenv("WORKSPACE_AUTH_ACTOR_HEADER", "X-Workspace-Actor-Id"): os.getenv(
                        "WORKSPACE_AUTH_ACTOR_ID", "e2e-workspace"
                    ),
                    os.getenv("WORKSPACE_AUTH_ROLES_HEADER", "X-Workspace-Roles"): os.getenv(
                        "WORKSPACE_AUTH_ROLES", "developer,devops"
                    ),
                }
            )
        if payload is not None:
            data = json.dumps(payload).encode("utf-8")

        req = urllib.request.Request(url, data=data, method=method, headers=headers)
        try:
            with urllib.request.urlopen(req, timeout=timeout) as response:
                body = response.read().decode("utf-8")
                return response.getcode(), (json.loads(body) if body else {})
        except urllib.error.HTTPError as exc:
            body = exc.read().decode("utf-8")
            try:
                parsed = json.loads(body) if body else {}
            except Exception:
                parsed = {"raw": body}
            return exc.code, parsed

    def record_step(self, name: str, status: str, data: Any | None = None) -> None:
        entry: dict[str, Any] = {"at": self.now_iso(), "step": name, "status": status}
        if data is not None:
            entry["data"] = data
        self.evidence["steps"].append(entry)

    def extract_error(self, invocation: dict[str, Any] | None, body: dict[str, Any]) -> dict[str, Any]:
        if isinstance(invocation, dict) and isinstance(invocation.get("error"), dict):
            return invocation["error"]
        if isinstance(body.get("error"), dict):
            return body["error"]
        return {}

    def record_invocation(
        self,
        *,
        session_id: str,
        tool: str,
        http_status: int,
        invocation: dict[str, Any] | None,
        body: dict[str, Any],
    ) -> None:
        error = self.extract_error(invocation, body)
        self.evidence["invocations"].append(
            {
                "at": self.now_iso(),
                "session_id": session_id,
                "tool": tool,
                "http_status": http_status,
                "invocation_id": invocation.get("id") if isinstance(invocation, dict) else None,
                "invocation_status": invocation.get("status") if isinstance(invocation, dict) else None,
                "error_code": error.get("code"),
                "error_message": error.get("message"),
            }
        )

    def create_session(
        self,
        *,
        payload: dict[str, Any],
        session_record: dict[str, Any] | None = None,
    ) -> str:
        status, body = self.request("POST", "/v1/sessions", payload)
        if status != 201:
            raise RuntimeError(f"create session failed ({status}): {body}")

        session_id = str(body.get("session", {}).get("id", "")).strip()
        if not session_id:
            raise RuntimeError(f"create session missing id: {body}")

        self.sessions.append(session_id)
        entry: dict[str, Any] = {"at": self.now_iso(), "session_id": session_id}
        if session_record is not None:
            entry.update(session_record)
        else:
            entry["payload"] = payload
        self.evidence["sessions"].append(entry)
        return session_id

    def invoke(
        self,
        *,
        session_id: str,
        tool_name: str,
        args: dict[str, Any],
        approved: bool = False,
        timeout: int = 120,
    ) -> tuple[int, dict[str, Any], dict[str, Any] | None]:
        self.invocation_counter += 1
        payload = {
            "correlation_id": f"{self.run_id}-{self.invocation_counter:04d}",
            "approved": approved,
            "args": args,
        }
        status, body = self.request(
            "POST",
            f"/v1/sessions/{session_id}/tools/{tool_name}/invoke",
            payload,
            timeout=timeout,
        )
        invocation = body.get("invocation") if isinstance(body, dict) else None
        self.record_invocation(
            session_id=session_id,
            tool=tool_name,
            http_status=status,
            invocation=invocation if isinstance(invocation, dict) else None,
            body=body if isinstance(body, dict) else {},
        )
        return status, body, invocation if isinstance(invocation, dict) else None

    def assert_invocation_succeeded(
        self,
        *,
        invocation: dict[str, Any] | None,
        body: dict[str, Any],
        label: str,
    ) -> None:
        if invocation is None:
            raise RuntimeError(f"{label}: missing invocation")
        status = str(invocation.get("status", "")).strip()
        if status != "succeeded":
            error = self.extract_error(invocation, body)
            code = str(error.get("code", "")).strip()
            raise RuntimeError(f"{label}: expected succeeded, got {status} ({code})")

    def assert_policy_denied(
        self,
        *,
        status: int,
        body: dict[str, Any],
        invocation: dict[str, Any] | None,
        label: str,
    ) -> None:
        if invocation is None:
            raise RuntimeError(f"{label}: missing invocation in response body")

        code = str(self.extract_error(invocation, body).get("code", "")).strip()
        if code != "policy_denied":
            raise RuntimeError(
                f"{label}: expected policy_denied, got code={code}, status={status}, body={body}"
            )

    def assert_not_policy_denied(
        self,
        *,
        status: int,
        body: dict[str, Any],
        invocation: dict[str, Any] | None,
        label: str,
    ) -> None:
        if invocation is None:
            raise RuntimeError(f"{label}: missing invocation in response body")

        code = str(self.extract_error(invocation, body).get("code", "")).strip()
        if code in ("policy_denied", "approval_required"):
            raise RuntimeError(f"{label}: unexpected policy block ({code})")

        inv_status = str(invocation.get("status", "")).strip()
        if inv_status != "succeeded":
            raise RuntimeError(
                f"{label}: expected succeeded invocation, got status={inv_status}, status={status}, body={body}"
            )

    def write_evidence(self, status: str, error_message: str = "") -> None:
        self.evidence["status"] = status
        self.evidence["ended_at"] = self.now_iso()
        if error_message:
            self.evidence["error_message"] = error_message

        try:
            with open(self.evidence_file, "w", encoding="utf-8") as handle:
                json.dump(self.evidence, handle, ensure_ascii=False, indent=2)
            print_warning(f"Evidence file: {self.evidence_file}")
        except Exception as exc:
            print_warning(f"Could not write evidence file: {exc}")

        print("EVIDENCE_JSON_START")
        print(json.dumps(self.evidence, ensure_ascii=False, indent=2))
        print("EVIDENCE_JSON_END")

    def cleanup_sessions(self) -> None:
        for session_id in self.sessions:
            try:
                self.request("DELETE", f"/v1/sessions/{session_id}")
            except Exception:
                pass
