# üêõ BUG CR√çTICO: asyncio.run() en VLLMAgent (AsyncVLLMAgent)

**Fecha**: 20 de Octubre de 2025  
**Severidad**: üî¥ **CR√çTICA** - Bloquea deliberaciones autom√°ticas  
**Estado**: üìù DOCUMENTADO - Pendiente de Fix  

---

## üéØ Resumen del Problema

El sistema de auto-dispatch est√° funcionando correctamente, pero falla al ejecutar deliberaciones debido a `asyncio.run()` siendo llamado desde un event loop ya corriendo.

---

## üîç An√°lisis del Error

### Error Completo

```
RuntimeError: asyncio.run() cannot be called from a running event loop

Traceback:
  File "services/orchestrator/application/services/auto_dispatch_service.py", line 162
    result = await deliberate_uc.execute(...)
  
  File "services/orchestrator/application/usecases/deliberate_usecase.py", line 101
    results = await council.execute(task_description, constraints)
  
  File "src/swe_ai_fleet/orchestrator/usecases/peer_deliberation_usecase.py", line 47
    result = a.generate(task, constraints, diversity=True)
  
  File "src/swe_ai_fleet/orchestrator/domain/agents/vllm_agent.py", line 342
    return asyncio.run(super().generate(task, constraints, diversity))
           ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
```

---

## üî¥ Root Cause: AsyncVLLMAgent Sync Wrappers

### Ubicaci√≥n del C√≥digo Problem√°tico

**Archivo**: `src/swe_ai_fleet/orchestrator/domain/agents/vllm_agent.py`  
**L√≠neas**: 332-351

```python
class AsyncVLLMAgent(VLLMAgent):
    """Async wrapper for VLLMAgent to maintain sync interface compatibility."""
    
    def generate(self, task: str, constraints: TaskConstraints, diversity: bool = False) -> dict[str, Any]:
        """Sync wrapper for async generate."""
        return asyncio.run(super().generate(task, constraints, diversity))  # ‚Üê ‚ùå L√çNEA 342
    
    def critique(self, proposal: str, rubric: dict[str, Any]) -> str:
        """Sync wrapper for async critique."""
        return asyncio.run(super().critique(proposal, rubric))  # ‚Üê ‚ùå L√çNEA 346
    
    def revise(self, content: str, feedback: str) -> str:
        """Sync wrapper for async revise."""
        return asyncio.run(super().revise(content, feedback))  # ‚Üê ‚ùå L√çNEA 350
```

---

## üé≠ Contexto del Problema

### Flujo de Ejecuci√≥n

```
1. gRPC Server (async event loop corriendo)
   ‚Üì
2. PlanningConsumer.handle_plan_approved() [async]
   ‚Üì
3. AutoDispatchService.dispatch_deliberations_for_plan() [async]
   ‚Üì
4. DeliberateUseCase.execute() [async]
   ‚Üì
5. Deliberate.execute() (peer_deliberation_usecase.py) [async]
   ‚Üì
6. agent.generate() ‚Üí AsyncVLLMAgent.generate() [SYNC wrapper]
   ‚Üì
7. asyncio.run(super().generate(...))  ‚ùå BOOM!
   
   ERROR: Ya hay un event loop corriendo (del gRPC server)
```

---

## ü§î ¬øPor Qu√© Existe AsyncVLLMAgent?

### Historia

**Problema Original**: 
- `VLLMAgent` (base) tiene m√©todos async
- Algunos callers quer√≠an interface sync
- Se cre√≥ `AsyncVLLMAgent` con wrappers sync usando `asyncio.run()`

**Cu√°ndo Funcionaba**:
- ‚úÖ Cuando se llamaba desde c√≥digo sync (sin event loop)
- ‚úÖ En scripts CLI
- ‚úÖ En notebooks

**Cu√°ndo NO Funciona**:
- ‚ùå Desde gRPC server async (event loop corriendo)
- ‚ùå Desde FastAPI async endpoints
- ‚ùå Desde NATS consumers async

---

## ‚úÖ Soluciones Propuestas

### Soluci√≥n 1: Eliminar AsyncVLLMAgent (RECOMENDADA)

**Raz√≥n**: Ya no se necesita porque TODO el flujo es async

**Cambios Requeridos**:

1. **Eliminar clase** `AsyncVLLMAgent` (l√≠neas 332-351)
   
2. **Actualizar** `agent_factory.py`:
```python
# ANTES:
from .vllm_agent import AsyncVLLMAgent
return AsyncVLLMAgent(...)

# DESPU√âS:
from .vllm_agent import VLLMAgent
return VLLMAgent(...)  # ‚Üê Usa la clase base async directamente
```

3. **Actualizar** `peer_deliberation_usecase.py` (ya est√° listo):
```python
# Ya detecta y awaitea correctamente:
result = a.generate(...)
if hasattr(result, '__await__'):
    result = await result  # ‚úÖ Ya implementado
```

4. **Actualizar tests** que usen `AsyncVLLMAgent` ‚Üí `VLLMAgent`

**Estimaci√≥n**: 30 minutos

**Impacto**: 
- ‚úÖ Elimina code smell (asyncio.run() en async context)
- ‚úÖ Simplifica c√≥digo (una clase menos)
- ‚úÖ Desbloquea auto-dispatch
- ‚ùå Breaking change para callers sync (si existen)

---

### Soluci√≥n 2: Detectar Event Loop y Usar Async

**Raz√≥n**: Mantener compatibilidad sync/async

**Cambios Requeridos**:

```python
class AsyncVLLMAgent(VLLMAgent):
    def generate(self, task: str, constraints: TaskConstraints, diversity: bool = False) -> dict[str, Any]:
        """Smart wrapper: async si hay event loop, sync si no."""
        try:
            # Check if event loop is running
            loop = asyncio.get_running_loop()
            # If we're here, loop is running ‚Üí return coroutine
            return super().generate(task, constraints, diversity)  # Returns coroutine
        except RuntimeError:
            # No event loop ‚Üí use asyncio.run
            return asyncio.run(super().generate(task, constraints, diversity))
```

**Estimaci√≥n**: 15 minutos

**Impacto**:
- ‚úÖ Mantiene compatibilidad sync
- ‚úÖ Funciona en contextos async
- ‚ö†Ô∏è M√°s complejo
- ‚ö†Ô∏è Retorna tipos diferentes (dict vs coroutine)

---

### Soluci√≥n 3: Crear Dos Interfaces Separadas

**Raz√≥n**: Separar completamente sync vs async

```python
class VLLMAgent(Agent):  # Async
    async def generate(...) -> dict:
        pass

class VLLMAgentSync:  # Sync (usa asyncio.run internamente)
    def generate(...) -> dict:
        return asyncio.run(VLLMAgent(...).generate(...))
```

**Estimaci√≥n**: 45 minutos

**Impacto**:
- ‚úÖ Claridad m√°xima (dos clases distintas)
- ‚úÖ No confusi√≥n
- ‚ö†Ô∏è Duplicaci√≥n de c√≥digo
- ‚ö†Ô∏è M√°s mantenimiento

---

## üéØ Recomendaci√≥n: **Soluci√≥n 1** (Eliminar AsyncVLLMAgent)

### Razones:

1. **TODO el flujo es async ahora**:
   - gRPC server ‚Üí async
   - PlanningConsumer ‚Üí async  
   - AutoDispatchService ‚Üí async
   - DeliberateUseCase ‚Üí async
   - Deliberate (peer_deliberation) ‚Üí async
   
2. **peer_deliberation_usecase.py YA detecta y awaitea**:
```python
result = a.generate(task, constraints, diversity=True)
if hasattr(result, '__await__'):
    result = await result  # ‚úÖ Ya implementado
```

3. **Simplifica el c√≥digo**:
   - Una clase menos
   - Sin wrappers sync innecesarios
   - Sin asyncio.run() problem√°tico

4. **Tests tambi√©n son async**:
   - Ya usan `asyncio.run()` en pytest
   - No necesitan interface sync

---

## üìã Plan de Implementaci√≥n (Soluci√≥n 1)

### Paso 1: Eliminar AsyncVLLMAgent

**Archivo**: `src/swe_ai_fleet/orchestrator/domain/agents/vllm_agent.py`

```python
# ELIMINAR l√≠neas 332-351:
class AsyncVLLMAgent(VLLMAgent):
    """Async wrapper for VLLMAgent to maintain sync interface compatibility."""
    # ... todo esto se elimina
```

---

### Paso 2: Actualizar Agent Factory

**Archivo**: `src/swe_ai_fleet/orchestrator/domain/agents/agent_factory.py`

```python
# ANTES (l√≠nea 15):
from .vllm_agent import AsyncVLLMAgent

# DESPU√âS:
from .vllm_agent import VLLMAgent

# ANTES (l√≠nea 121):
return AsyncVLLMAgent(...)

# DESPU√âS:
return VLLMAgent(...)
```

---

### Paso 3: Actualizar Tests

**Archivo**: `tests/unit/test_vllm_agent_unit.py`

```python
# Find/replace:
AsyncVLLMAgent ‚Üí VLLMAgent

# Verificar que tests usen await:
result = await agent.generate(...)  # ‚úÖ
```

---

### Paso 4: Verificar Peer Deliberation

**Archivo**: `src/swe_ai_fleet/orchestrator/usecases/peer_deliberation_usecase.py`

```python
# Ya est√° correcto (l√≠neas 47-50):
result = a.generate(task, constraints, diversity=True)
if hasattr(result, '__await__'):
    result = await result  # ‚úÖ Detecta y awaitea
```

**NO requiere cambios** ‚úÖ

---

### Paso 5: Testing

```bash
# 1. Unit tests
source .venv/bin/activate
pytest tests/unit/test_vllm_agent_unit.py -v

# 2. Orchestrator tests
pytest services/orchestrator/tests/ -v

# 3. Integration tests
pytest tests/unit/orchestrator/test_deliberate_integration.py -v
```

---

### Paso 6: Rebuild & Redeploy

```bash
# Build
podman build --no-cache -f services/orchestrator/Dockerfile \
  -t registry.underpassai.com/swe-fleet/orchestrator:v2.8.0-async-agents .

# Push
podman push registry.underpassai.com/swe-fleet/orchestrator:v2.8.0-async-agents

# Deploy
kubectl set image -n swe-ai-fleet deployment/orchestrator \
  orchestrator=registry.underpassai.com/swe-fleet/orchestrator:v2.8.0-async-agents

# Restart clean
kubectl scale deployment/orchestrator -n swe-ai-fleet --replicas=0
sleep 5
kubectl scale deployment/orchestrator -n swe-ai-fleet --replicas=1
```

---

### Paso 7: E2E Test

```bash
# Run auto-dispatch test
kubectl delete job -n swe-ai-fleet test-auto-dispatch
kubectl apply -f deploy/k8s/98-test-auto-dispatch-job.yaml

# Watch orchestrator logs for deliberation
kubectl logs -n swe-ai-fleet -l app=orchestrator -f
```

**Buscar en logs**:
- ‚úÖ `üöÄ Auto-dispatching deliberations for 1 roles: DEV`
- ‚úÖ `üé≠ Starting deliberation for DEV`
- ‚úÖ `‚úÖ Deliberation completed for DEV: X proposals in Yms`

---

## üìä Archivos Afectados

| Archivo | Tipo de Cambio | L√≠neas Afectadas |
|---------|----------------|------------------|
| `src/.../vllm_agent.py` | DELETE class | 332-351 (20 l√≠neas) |
| `src/.../agent_factory.py` | REPLACE import/return | 15, 105, 119, 121 |
| `tests/unit/test_vllm_agent_unit.py` | FIND/REPLACE | ~10 referencias |

**Total**: 3 archivos, ~30 l√≠neas de cambios

---

## üéì Lecciones Aprendidas

### 1. asyncio.run() es Peligroso en Async Context

**Regla**: NUNCA usar `asyncio.run()` dentro de c√≥digo que puede ser llamado desde un event loop async.

**Detectar**: Si tu c√≥digo puede ser llamado desde:
- gRPC server async
- FastAPI async endpoints
- NATS consumers async
- Cualquier `async def` function

‚Üí **NO uses `asyncio.run()`**

---

### 2. Sync Wrappers Sobre Async Son Code Smell

Si tienes:
```python
class AsyncWrapper(BaseAsync):
    def sync_method(self):
        return asyncio.run(self.async_method())  # ‚Üê Code smell
```

**Mejor**:
- Eliminar wrapper
- Hacer TODO async
- Usar `await` directamente

---

### 3. Detection Pattern en Deliberate Est√° Correcto

```python
# peer_deliberation_usecase.py (l√≠neas 47-50)
result = a.generate(task, constraints, diversity=True)
if hasattr(result, '__await__'):
    result = await result  # ‚úÖ Detecta y awaitea
```

Este patr√≥n **ES CORRECTO** y ya maneja ambos casos (sync/async).

El problema NO es el detector, es que el wrapper sync usa `asyncio.run()`.

---

## üö® Impacto del Bug

### ‚ùå Qu√© NO Funciona

1. **Auto-dispatch de deliberaciones** desde planning consumer
2. **Deliberaciones triggereadas por eventos** NATS
3. **Cualquier deliberaci√≥n** iniciada desde async context

### ‚úÖ Qu√© S√ç Funciona

1. **Deliberaciones v√≠a gRPC `Deliberate` RPC** directamente (FALSO - tambi√©n falla)
2. **Unit tests** (usan `asyncio.run()` en pytest, no en agent)
3. **Scripts sync** que llaman deliberaciones

---

## üîß Workaround Temporal

**NINGUNO** - Este bug bloquea completamente las deliberaciones autom√°ticas.

La √∫nica forma de ejecutar deliberaciones ser√≠a:
1. Modificar agent factory para usar `VLLMAgent` directamente (no `AsyncVLLMAgent`)
2. Rebuild y redeploy

**No hay workaround sin c√≥digo changes.**

---

## üìÖ Pr√≥ximo Fix (Estimaci√≥n: 45 minutos)

### Timeline:

1. **Eliminar `AsyncVLLMAgent`** (5 min)
2. **Actualizar `agent_factory.py`** (2 min)
3. **Actualizar tests** (10 min)
4. **Run all tests** (5 min)
5. **Rebuild orchestrator** (5 min)
6. **Push & deploy** (3 min)
7. **E2E test auto-dispatch** (5 min)
8. **Verification** (10 min)

**Total**: ~45 minutos para fix completo

---

## üéØ Success Criteria

Fix ser√° exitoso cuando veamos en logs:

```
üöÄ Auto-dispatching deliberations for 1 roles: DEV
üé≠ Starting deliberation for DEV: Implement plan plan-test-clean-arch...
‚úÖ Deliberation completed for DEV: 3 proposals in 2500ms
```

**Sin errores de asyncio.run()**

---

## üìñ Referencias

- **Python asyncio docs**: https://docs.python.org/3/library/asyncio-task.html#asyncio.run
- **Issue similar**: https://github.com/python/cpython/issues/90908
- **Best practices**: No anidar `asyncio.run()` calls

---

## ‚úçÔ∏è Notas del Arquitecto

Este bug demuestra la importancia de:

1. **Testing end-to-end** - Los unit tests no capturaron esto
2. **Event loop awareness** - Conocer el contexto de ejecuci√≥n
3. **Async all the way** - Si el stack es async, TODO debe ser async
4. **Eliminar abstracciones innecesarias** - AsyncVLLMAgent es un wrapper innecesario

**Este fix es cr√≠tico para desbloquear el sistema completo.** üéØ

---

## üîÑ Estado Actual

- ‚úÖ Auto-dispatch implementado (c√≥digo perfecto)
- ‚úÖ AutoDispatchService creado (arquitectura limpia)
- ‚úÖ Planning consumer refactorizado (sin code smells)
- ‚úÖ Tests pasando (6/6 planning consumer)
- ‚ùå **BLOQUEADO por AsyncVLLMAgent.asyncio.run()**

**Una vez arreglado este bug, el sistema completo funcionar√° end-to-end!** üöÄ


