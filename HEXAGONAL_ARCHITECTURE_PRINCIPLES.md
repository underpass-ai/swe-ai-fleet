# üèõÔ∏è Hexagonal Architecture - Principios NO Negociables

**Fecha**: 20 de Octubre de 2025  
**Autor**: Tirso (Lead Architect)  
**Estado**: üìú **DOCUMENTO NORMATIVO** - Cumplimiento Obligatorio

---

## ‚ö†Ô∏è IMPORTANTE: Esta Arquitectura Es de Libro

La arquitectura hexagonal implementada en este proyecto es **ejemplar** y **de libro de texto**. Ha sido cuidadosamente dise√±ada por el arquitecto del proyecto y debe ser **mantenida y cuidada** con el m√°ximo rigor.

### üéØ Prop√≥sito de Este Documento

Este documento establece los **principios NO negociables** que TODOS los desarrolladores deben seguir al trabajar en este proyecto. La arquitectura hexagonal no es opcional, es la base del proyecto.

---

## üìê ¬øQu√© Es Arquitectura Hexagonal?

### Definici√≥n

Arquitectura Hexagonal (tambi√©n conocida como **Ports & Adapters**) es un patr√≥n arquitect√≥nico que:

1. **Separa el dominio de negocio** de los detalles t√©cnicos
2. **Invierte las dependencias** - todo apunta hacia el dominio
3. **Usa abstracciones (ports)** para comunicaci√≥n entre capas
4. **Implementa adapters** que concretan los ports

### Diagrama Conceptual

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     INFRASTRUCTURE                              ‚îÇ
‚îÇ                   (Adapters - Driving)                          ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  gRPC Server, REST API, Event Handlers                    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  (Entry points - adaptan el mundo exterior al dominio)    ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
                          ‚îÇ Llama a trav√©s de Ports
                          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     APPLICATION                                 ‚îÇ
‚îÇ                  (Application Services)                         ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  Use Cases (Deliberate, Orchestrate, etc.)                ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  Application Services (AutoDispatchService)               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  (Orquestaci√≥n de l√≥gica de negocio)                     ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
                          ‚îÇ Usa
                          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        DOMAIN                                   ‚îÇ
‚îÇ                   (Business Logic)                              ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  Entities (OrchestratorStatistics, CouncilRegistry)       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  Value Objects (Role, TaskConstraints)                    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  Domain Services (Deliberate algorithm)                   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  Ports (Interfaces - MessagingPort, CouncilQueryPort)     ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
                          ‚îÇ Implementado por
                          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     INFRASTRUCTURE                              ‚îÇ
‚îÇ                    (Adapters - Driven)                          ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  NATSMessagingAdapter, CouncilQueryAdapter                ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  (Implementaciones concretas de infraestructura)          ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üéì Principios Fundamentales (De Libro)

### 1. **Dependency Inversion**

```python
# ‚ùå MAL - Domain depende de Infrastructure
class DeliberateUseCase:
    def __init__(self):
        self.messaging = NATSClient()  # ‚Üê Dependencia directa de infraestructura
```

```python
# ‚úÖ BIEN - Domain depende de abstracci√≥n
class DeliberateUseCase:
    def __init__(self, messaging: MessagingPort):  # ‚Üê Depende de Port (abstracci√≥n)
        self._messaging = messaging
```

**Regla**: El dominio NUNCA importa de infrastructure. Infrastructure implementa las interfaces (ports) definidas en domain.

---

### 2. **Ports & Adapters**

#### Port (Abstracci√≥n en Domain)

```python
# services/orchestrator/domain/ports/messaging_port.py

from abc import ABC, abstractmethod

class MessagingPort(ABC):
    """Port for messaging operations.
    
    This is an ABSTRACTION. Domain defines WHAT it needs,
    not HOW it's implemented.
    """
    
    @abstractmethod
    async def publish_event(self, event: DomainEvent) -> None:
        """Publish a domain event."""
        pass
    
    @abstractmethod
    async def subscribe(self, subject: str, handler: Callable) -> None:
        """Subscribe to events."""
        pass
```

#### Adapter (Implementaci√≥n en Infrastructure)

```python
# services/orchestrator/infrastructure/adapters/nats_messaging_adapter.py

class NATSMessagingAdapter(MessagingPort):
    """Adapter implementing MessagingPort using NATS.
    
    This is an IMPLEMENTATION. Infrastructure decides HOW
    to implement the port.
    """
    
    def __init__(self, nats_client: NATS):
        self._nats = nats_client
    
    async def publish_event(self, event: DomainEvent) -> None:
        # NATS-specific implementation
        await self._nats.publish(...)
```

**Regla**: 
- **Ports** se definen en `domain/ports/`
- **Adapters** se implementan en `infrastructure/adapters/`
- Domain solo conoce Ports
- Infrastructure implementa Adapters

---

### 3. **Application Services (Facades)**

```python
# services/orchestrator/application/services/auto_dispatch_service.py

class AutoDispatchService:
    """Application Service that orchestrates use cases.
    
    This is the ORCHESTRATION layer between infrastructure
    and domain. It coordinates multiple use cases and ports.
    """
    
    def __init__(
        self,
        council_query: CouncilQueryPort,  # ‚Üê Port
        council_registry: CouncilRegistry,  # ‚Üê Domain entity
        stats: OrchestratorStatistics,  # ‚Üê Domain entity
        messaging: MessagingPort,  # ‚Üê Port
    ):
        # All dependencies injected via constructor
        pass
    
    async def dispatch_deliberations_for_plan(self, event: PlanApprovedEvent):
        # Orchestrates:
        # 1. Query via port
        # 2. Get from domain entity
        # 3. Create and execute use case
        # 4. Publish via port
        pass
```

**Regla**: 
- Application Services orquestan use cases
- NO contienen l√≥gica de negocio
- Coordinan entre domain y infrastructure
- Simplifican la interface para handlers

---

### 4. **Clean Dependency Injection**

```python
# services/orchestrator/server.py (Composition Root)

async def serve_async():
    # 1. Create infrastructure adapters
    nats_adapter = NATSMessagingAdapter(nats_client)
    council_query_adapter = CouncilQueryAdapter(default_model="qwen")
    
    # 2. Create domain entities
    council_registry = CouncilRegistry()
    stats = OrchestratorStatistics()
    
    # 3. Create application services (inject dependencies)
    auto_dispatch_service = AutoDispatchService(
        council_query=council_query_adapter,  # Adapter
        council_registry=council_registry,  # Entity
        stats=stats,  # Entity
        messaging=nats_adapter,  # Adapter
    )
    
    # 4. Create handlers (inject services)
    planning_consumer = PlanningConsumer(
        council_query=council_query_adapter,
        messaging=nats_adapter,
        auto_dispatch_service=auto_dispatch_service,  # Service
    )
```

**Regla**: 
- Toda la inyecci√≥n de dependencias ocurre en **UN solo lugar** (Composition Root)
- NO usar `new` dentro de clases (excepto value objects)
- NO usar imports din√°micos
- Todas las dependencias por constructor

---

## üö´ Antipatrones - PROHIBIDOS

### ‚ùå 1. Dynamic Imports

```python
# ‚ùå PROHIBIDO
def handle_event(self, event):
    from services.orchestrator.application.usecases import DeliberateUseCase  # ‚Üê NO!
    use_case = DeliberateUseCase(...)
```

**Por qu√© est√° mal**:
- Rompe Dependency Inversion
- Acopla infrastructure con application
- Dif√≠cil de testear
- Oculta dependencias

**C√≥mo arreglarlo**:
- Inyectar use case o service por constructor
- Crear Application Service si hay orchestraci√≥n compleja

---

### ‚ùå 2. God Classes

```python
# ‚ùå PROHIBIDO
class PlanningConsumer:
    async def handle_plan_approved(self, msg):
        # 100 l√≠neas de l√≥gica:
        # - Validaci√≥n
        # - Query de councils
        # - Creaci√≥n de use cases
        # - Ejecuci√≥n de deliberaciones
        # - Publicaci√≥n de eventos
        # ‚Üê Demasiadas responsabilidades!
```

**Por qu√© est√° mal**:
- Viola Single Responsibility Principle
- Dif√≠cil de testear
- Dif√≠cil de mantener

**C√≥mo arreglarlo**:
- Delegar a Application Service
- Handler solo consume y delega

---

### ‚ùå 3. Infrastructure en Domain

```python
# ‚ùå PROHIBIDO - services/orchestrator/domain/entities/statistics.py
import nats  # ‚Üê Domain NO debe importar infrastructure!

class OrchestratorStatistics:
    def publish_metrics(self):
        # Llamada directa a NATS
        await nats.publish(...)  # ‚Üê NO!
```

**Por qu√© est√° mal**:
- Domain acoplado a tecnolog√≠a espec√≠fica
- Imposible cambiar NATS sin tocar domain
- Viola Dependency Inversion

**C√≥mo arreglarlo**:
- Domain publica DomainEvents
- Infrastructure escucha y publica a NATS

---

### ‚ùå 4. Anemic Domain Model

```python
# ‚ùå PROHIBIDO
class TaskConstraints:
    rubric: dict
    architect_rubric: dict
    # ‚Üê Solo datos, sin comportamiento

class TaskConstraintsValidator:  # ‚Üê L√≥gica separada de datos
    def validate(self, constraints: TaskConstraints):
        # Validaci√≥n aqu√≠
```

**Por qu√© est√° mal**:
- L√≥gica de negocio fuera del dominio
- Datos y comportamiento separados
- No es orientado a objetos

**C√≥mo arreglarlo**:
- Mover comportamiento al entity/value object
```python
class TaskConstraints:
    def validate(self) -> bool:
        # Validaci√≥n aqu√≠
        pass
```

---

## ‚úÖ Patrones Correctos - SEGUIR

### ‚úÖ 1. Application Service Pattern

```python
# ‚úÖ CORRECTO
class AutoDispatchService:
    """Orchestrates deliberation dispatch without business logic."""
    
    def __init__(
        self,
        council_query: CouncilQueryPort,
        council_registry: CouncilRegistry,
        stats: OrchestratorStatistics,
        messaging: MessagingPort,
    ):
        # Dependency Injection
        pass
    
    async def dispatch_deliberations_for_plan(self, event):
        # Orchestration (no business logic):
        # 1. Query via port
        # 2. Create use case
        # 3. Execute use case
        # 4. Publish via port
        pass
```

**Por qu√© es correcto**:
- Separa orchestraci√≥n de l√≥gica de negocio
- Dependency Injection clara
- Testeable (mock ports)
- Single Responsibility

---

### ‚úÖ 2. Port/Adapter Pattern

```python
# ‚úÖ CORRECTO - Domain define port
class CouncilQueryPort(ABC):
    @abstractmethod
    def has_council(self, role: str, registry: CouncilRegistry) -> bool:
        pass

# ‚úÖ CORRECTO - Infrastructure implementa adapter
class CouncilQueryAdapter(CouncilQueryPort):
    def has_council(self, role: str, registry: CouncilRegistry) -> bool:
        try:
            return registry.has_council(role)
        except Exception:
            return False
```

**Por qu√© es correcto**:
- Domain define interfaz (WHAT)
- Infrastructure implementa (HOW)
- Dependency Inversion respetada
- F√°cil cambiar implementaci√≥n

---

### ‚úÖ 3. Domain Events

```python
# ‚úÖ CORRECTO - Domain publica eventos
@dataclass(frozen=True)
class DeliberationCompletedEvent(DomainEvent):
    deliberation_id: str
    story_id: str
    role: str
    timestamp: str
    
    @property
    def event_type(self) -> str:
        return "orchestration.deliberation.completed"

# ‚úÖ CORRECTO - Use case publica via port
class DeliberateUseCase:
    async def execute(self, ...):
        results = await council.execute(...)
        
        # Publish domain event via port
        event = DeliberationCompletedEvent(...)
        await self._messaging.publish_event(event)
```

**Por qu√© es correcto**:
- Domain events son parte del domain
- Publicaci√≥n via port (abstracci√≥n)
- Desacoplamiento entre servicios

---

## üìã Checklist para Pull Requests

Antes de hacer merge, verificar:

### Domain Layer
- [ ] ‚ùå NO importa de `infrastructure`
- [ ] ‚ùå NO importa de `application` (excepto types)
- [ ] ‚úÖ Define ports (interfaces) para dependencias externas
- [ ] ‚úÖ Entities tienen comportamiento, no solo datos
- [ ] ‚úÖ Value Objects son inmutables
- [ ] ‚úÖ Domain Events heredan de `DomainEvent`

### Application Layer
- [ ] ‚ùå NO importa de `infrastructure`
- [ ] ‚úÖ Use Cases dependen de ports, no adapters
- [ ] ‚úÖ Application Services solo orquestan, no l√≥gica de negocio
- [ ] ‚úÖ Todas las dependencias por constructor

### Infrastructure Layer
- [ ] ‚úÖ Adapters implementan ports
- [ ] ‚úÖ Handlers delegan a Application Services
- [ ] ‚ùå NO dynamic imports
- [ ] ‚úÖ Dependency Injection en Composition Root

### Tests
- [ ] ‚úÖ Mockean ports, no implementaciones
- [ ] ‚úÖ Verifican behavior, no implementation
- [ ] ‚úÖ Tests de domain sin infrastructure
- [ ] ‚úÖ Tests de infrastructure con testcontainers si necesario

---

## üìö Estructura de Directorios (Referencia)

```
services/orchestrator/
‚îú‚îÄ‚îÄ domain/                          # üîµ DOMAIN (Core Business Logic)
‚îÇ   ‚îú‚îÄ‚îÄ entities/                    # Entities con comportamiento
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orchestrator_statistics.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ council_registry.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ incoming_events.py       # Events from other services
‚îÇ   ‚îú‚îÄ‚îÄ events/                      # Domain Events (outgoing)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain_event.py          # Base class
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deliberation_completed_event.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ plan_approved_event.py
‚îÇ   ‚îú‚îÄ‚îÄ ports/                       # Interfaces (contracts)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ messaging_port.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ council_query_port.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deliberation_tracker_port.py
‚îÇ   ‚îî‚îÄ‚îÄ value_objects/               # Immutable values
‚îÇ       ‚îú‚îÄ‚îÄ role.py
‚îÇ       ‚îî‚îÄ‚îÄ agent_type.py
‚îÇ
‚îú‚îÄ‚îÄ application/                     # üü° APPLICATION (Orchestration)
‚îÇ   ‚îú‚îÄ‚îÄ usecases/                    # Use cases (business flows)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deliberate_usecase.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ create_council_usecase.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ list_councils_usecase.py
‚îÇ   ‚îî‚îÄ‚îÄ services/                    # Application Services (facades)
‚îÇ       ‚îî‚îÄ‚îÄ auto_dispatch_service.py # ‚Üê Orchestrates use cases
‚îÇ
‚îú‚îÄ‚îÄ infrastructure/                  # üü¢ INFRASTRUCTURE (Technical Details)
‚îÇ   ‚îú‚îÄ‚îÄ adapters/                    # Port implementations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ nats_messaging_adapter.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ council_query_adapter.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ environment_configuration_adapter.py
‚îÇ   ‚îú‚îÄ‚îÄ handlers/                    # Event handlers (entry points)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ planning_consumer.py     # ‚Üê Delegates to services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ context_consumer.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ agent_response_consumer.py
‚îÇ   ‚îú‚îÄ‚îÄ mappers/                     # DTO ‚Üî Domain mappers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ council_info_mapper.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deliberation_status_mapper.py
‚îÇ   ‚îî‚îÄ‚îÄ dto/                         # gRPC/REST DTOs
‚îÇ       ‚îî‚îÄ‚îÄ orchestrator_dto.py
‚îÇ
‚îú‚îÄ‚îÄ server.py                        # üîß COMPOSITION ROOT
‚îî‚îÄ‚îÄ tests/                           # üß™ TESTS (by layer)
    ‚îú‚îÄ‚îÄ domain/
    ‚îú‚îÄ‚îÄ application/
    ‚îî‚îÄ‚îÄ infrastructure/
```

---

## üéØ Beneficios de Esta Arquitectura

### 1. **Testability** (Probabilidad)
- Unit tests sin dependencias externas
- Mock ports, no implementaciones
- Tests r√°pidos (<0.01s por test)

### 2. **Maintainability** (Mantenibilidad)
- Cambios localizados
- Bajo acoplamiento
- Alta cohesi√≥n

### 3. **Flexibility** (Flexibilidad)
- F√°cil cambiar NATS por RabbitMQ
- F√°cil cambiar Neo4j por PostgreSQL
- F√°cil agregar nuevos adapters

### 4. **Clarity** (Claridad)
- Estructura predecible
- Responsabilidades claras
- F√°cil onboarding

---

## üîç Ejemplos Reales en Este Proyecto

### Ejemplo 1: AutoDispatchService

**Por qu√© es ejemplar**:
- ‚úÖ Application Service (orchestration)
- ‚úÖ Dependency Injection via constructor
- ‚úÖ Usa ports, no adapters
- ‚úÖ No tiene l√≥gica de negocio
- ‚úÖ Retorna datos estructurados

### Ejemplo 2: PlanningConsumer

**Por qu√© es ejemplar**:
- ‚úÖ Handler delega a service
- ‚úÖ 10 l√≠neas vs 70 l√≠neas originales
- ‚úÖ Single Responsibility (consume eventos)
- ‚úÖ No conoce detalles de deliberaci√≥n

### Ejemplo 3: CouncilQueryPort/Adapter

**Por qu√© es ejemplar**:
- ‚úÖ Port define interfaz en domain
- ‚úÖ Adapter implementa en infrastructure
- ‚úÖ Domain no conoce CouncilRegistry implementation
- ‚úÖ F√°cil mockear en tests

---

## ‚öñÔ∏è Cuando Romper las Reglas

### Regla General: **NUNCA**

Estas no son "guidelines", son **principios arquitect√≥nicos fundamentales**.

### Excepci√≥n √öNICA:

Si hay una raz√≥n **t√©cnica documentada y aprobada por el arquitecto**, se puede considerar.

**Proceso**:
1. Documentar el problema
2. Proponer alternativa
3. Discutir con el equipo
4. Obtener aprobaci√≥n del arquitecto (Tirso)
5. Documentar la decisi√≥n en ADR (Architecture Decision Record)

**Ejemplo v√°lido**: Performance cr√≠tico medido y documentado

**Ejemplos NO v√°lidos**:
- "Es m√°s r√°pido as√≠"
- "No entiendo hexagonal"
- "Es mucho c√≥digo"

---

## üìñ Recursos para Aprender

### Libros
1. **"Hexagonal Architecture Explained"** - Juan Manuel Garrido
2. **"Clean Architecture"** - Robert C. Martin
3. **"Domain-Driven Design"** - Eric Evans

### Art√≠culos
1. **"Hexagonal Architecture"** - Alistair Cockburn (original)
2. **"Ports and Adapters Pattern"** - Martin Fowler

### En Este Repositorio
1. `CLEAN_ARCHITECTURE_REFACTOR_20251020.md` - Refactor completo documentado
2. `ARCHITECTURE_CORE_VS_MICROSERVICES.md` - Separaci√≥n Core vs MS
3. `EVENTS_ARCHITECTURE.md` - INCOMING vs OUTGOING events
4. `ORCHESTRATOR_HEXAGONAL_CODE_ANALYSIS.md` - An√°lisis completo

---

## üéä Conclusi√≥n

> **Esta arquitectura es de LIBRO. No es negociable. Es la base del proyecto.**

### Compromiso del Equipo:

1. **LEER** este documento antes de hacer cambios
2. **SEGUIR** los principios sin excepci√≥n
3. **REVISAR** PRs con estos criterios
4. **RECHAZAR** PRs que violen estos principios
5. **EDUCAR** a nuevos miembros del equipo

### Responsabilidad del Arquitecto:

- Mantener esta documentaci√≥n actualizada
- Revisar arquitectura en cada PR importante
- Educar al equipo
- Proteger la integridad arquitect√≥nica

---

## ‚úçÔ∏è Firma del Arquitecto

**Tirso** - Lead Architect  
*Esta arquitectura hexagonal es el resultado de a√±os de experiencia y debe ser respetada y mantenida. Es lo que hace que este proyecto sea excepcional.*

---

## üìÖ Historial de Revisiones

| Fecha | Versi√≥n | Cambios |
|-------|---------|---------|
| 2025-10-20 | 1.0 | Documento inicial - Principios fundamentales |

---

**Este documento es normativo. Su cumplimiento es obligatorio para todos los contribuidores.**


