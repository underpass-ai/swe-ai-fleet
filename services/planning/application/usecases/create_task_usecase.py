"""CreateTaskUseCase - Create new task within a story."""

import logging
from dataclasses import dataclass
from datetime import UTC, datetime

from planning.application.ports import MessagingPort, StoragePort
from planning.domain.entities.task import Task
from planning.domain.value_objects.requests.create_task_request import CreateTaskRequest
from planning.domain.value_objects.statuses.task_status import TaskStatus

logger = logging.getLogger(__name__)


@dataclass
class CreateTaskUseCase:
    """Create a new task within a plan.

    This use case:
    1. Validates that parent plan (and story) exists
    2. Creates Task domain entity
    3. Persists to dual storage (Neo4j + Valkey)
    4. Creates PlanVersion→Task relationship in Neo4j
    5. Publishes planning.task.created event

    Following Hexagonal Architecture:
    - Depends on ports (StoragePort, MessagingPort)
    - Returns domain entity (Task)
    - No infrastructure dependencies
    - Uses Value Objects (NO primitives) - follows DDD strict
    """

    storage: StoragePort
    messaging: MessagingPort

    async def execute(self, request: CreateTaskRequest) -> Task:
        """Execute task creation.

        Args:
            request: CreateTaskRequest value object (all fields are VOs, NO primitives)

        Returns:
            Created Task entity

        Raises:
            ValueError: If plan_id is empty or parent plan not found
        """
        # Step 1: Validate parent story exists (domain invariant enforcement)
        parent_story = await self.storage.get_story(request.story_id)
        if not parent_story:
            raise ValueError(
                f"Cannot create Task: Story {request.story_id} not found. "
                "Domain Invariant: Task MUST belong to an existing Story (via Plan)."
            )

        # Step 2: Use task_id from request (already provided by caller)
        # If caller wants auto-generation, they should create TaskId before building request
        task_id = request.task_id

        # Step 3: Create Task domain entity (validation in __post_init__)
        # Task aligns with LLM output structure but IDs are Planning Service responsibility
        # Core fields from LLM: title, description, role, estimated_hours
        # IDs generated by Planning Service: task_id, plan_id, story_id (provided in request)
        # System metadata: timestamps, type, status, priority (Planning Service provides)
        now = datetime.now(UTC)
        task = Task(
            # Core fields from LLM (via request)
            task_id=task_id,
            story_id=request.story_id,  # Context: denormalized for fast lookups
            title=request.title.value,  # Convert Title VO → str
            created_at=now,  # System: creation timestamp
            updated_at=now,  # System: update timestamp

            # Optional fields
            plan_id=request.plan_id,  # Context: parent plan (optional)
            description=request.description.value,  # Convert TaskDescription VO → str
            assigned_to=str(request.assigned_to),  # Convert Role VO → str (uses __str__)
            estimated_hours=request.estimated_hours.to_hours(),  # Convert Duration VO → int
            type=request.task_type,  # System: task type
            status=TaskStatus.TODO,  # System: initial status
            priority=request.priority.to_int(),  # System: priority (from request or calculated)
        )

        # Step 4: Persist to dual storage (Neo4j + Valkey)
        # Neo4j will also create PlanVersion→Task relationship
        await self.storage.save_task(task)

        logger.info(
            f"Task created: {task_id} - {request.title.value} "
            f"(plan: {request.plan_id}, story: {request.story_id})"
        )

        # Step 5: Publish event (other services react)
        # Use case creates domain event, mapper handles serialization
        # Import here to avoid circular dependencies and protobuf generation issues in tests
        from planning.infrastructure.mappers.task_event_mapper import TaskEventMapper

        # Create domain event
        event = TaskEventMapper.task_to_created_event(task)

        # Convert to payload (infrastructure mapper)
        payload = TaskEventMapper.created_event_to_payload(event)

        # Publish via port
        await self.messaging.publish_event(
            subject="planning.task.created",
            payload=payload,
        )

        return task

