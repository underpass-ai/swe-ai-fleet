"""OrchestratorPort - Interface for Orchestrator Service integration.

This port defines the contract for coordinating multi-agent deliberations
via the Orchestrator Service.

Following Hexagonal Architecture:
- Port (interface) lives in application layer
- Adapter (implementation) lives in infrastructure layer
- Domain layer knows nothing about Orchestrator

Design Pattern: Fire-and-Forget (Async via NATS)
- deliberate() returns DeliberationId immediately (~30ms ACK)
- Actual deliberation happens asynchronously in Ray cluster
- Results published to NATS (agent.deliberation.completed)
- Consumer handles result processing
"""

from dataclasses import dataclass
from typing import Protocol

from planning.domain.value_objects.identifiers.deliberation_id import DeliberationId


@dataclass(frozen=True)
class TaskConstraints:
    """
    Constraints and requirements for task execution.

    Domain Invariants:
    - rubric can be empty (no specific rubric)
    - requirements is a tuple of strings (can be empty)
    - metadata is optional
    - timeout_seconds must be > 0 if specified
    - story_id is optional (required for backlog review ceremonies)
    """

    rubric: str = ""
    requirements: tuple[str, ...] = ()
    metadata: dict[str, str] | None = None
    max_iterations: int = 3
    timeout_seconds: int = 180
    story_id: str = ""

    def __post_init__(self) -> None:
        """
        Validate constraints (fail-fast).

        Raises:
            ValueError: If validation fails
        """
        if self.timeout_seconds <= 0:
            raise ValueError(f"timeout_seconds must be > 0, got {self.timeout_seconds}")

        if self.max_iterations <= 0:
            raise ValueError(f"max_iterations must be > 0, got {self.max_iterations}")


@dataclass(frozen=True)
class DeliberationRequest:
    """
    Request for multi-agent deliberation.

    Domain Invariants:
    - task_id is REQUIRED for backlog review ceremonies (format: "ceremony-{id}:story-{id}:role-{role}")
    - task_description cannot be empty
    - role must be valid (ARCHITECT, QA, DEVOPS, DEV, DATA)
    - rounds must be >= 1
    - num_agents must be >= 1
    """

    task_id: str  # REQUIRED for backlog review ceremonies (format: "ceremony-{id}:story-{id}:role-{role}")
    task_description: str
    role: str  # ARCHITECT, QA, DEVOPS, DEV, DATA
    constraints: TaskConstraints | None = None
    rounds: int = 1
    num_agents: int = 3

    def __post_init__(self) -> None:
        """
        Validate request (fail-fast).

        Raises:
            ValueError: If validation fails
        """
        if not self.task_id or not self.task_id.strip():
            raise ValueError("task_id cannot be empty (REQUIRED for backlog review ceremonies)")

        if not self.task_description or not self.task_description.strip():
            raise ValueError("task_description cannot be empty")

        valid_roles = ("ARCHITECT", "QA", "DEVOPS", "DEV", "DATA")
        if self.role not in valid_roles:
            raise ValueError(
                f"Invalid role: {self.role}. Must be one of {valid_roles}"
            )

        if self.rounds < 1:
            raise ValueError(f"rounds must be >= 1, got {self.rounds}")

        if self.num_agents < 1:
            raise ValueError(f"num_agents must be >= 1, got {self.num_agents}")


@dataclass(frozen=True)
class Proposal:
    """
    Proposal generated by an agent during deliberation.

    Represents a single agent's solution/recommendation.
    """

    author_id: str
    author_role: str
    content: str
    created_at_ms: int
    revisions: tuple[str, ...] = ()

    def __post_init__(self) -> None:
        """Validate proposal (fail-fast)."""
        if not self.author_id or not self.author_id.strip():
            raise ValueError("author_id cannot be empty")

        if not self.content or not self.content.strip():
            raise ValueError("content cannot be empty")

        if self.created_at_ms < 0:
            raise ValueError(f"created_at_ms must be >= 0, got {self.created_at_ms}")


@dataclass(frozen=True)
class DeliberationResult:
    """
    Result of a single agent's deliberation (proposal + evaluation).

    Contains the proposal, whether checks passed, score, and rank.
    """

    proposal: Proposal
    checks_passed: bool
    score: float
    rank: int

    def __post_init__(self) -> None:
        """Validate result (fail-fast)."""
        if self.score < 0.0 or self.score > 1.0:
            raise ValueError(f"score must be 0.0-1.0, got {self.score}")

        if self.rank < 1:
            raise ValueError(f"rank must be >= 1, got {self.rank}")


@dataclass(frozen=True)
class DeliberationResponse:
    """
    Response from Orchestrator deliberation.

    Contains all ranked proposals from the deliberation,
    the winner ID, and execution metadata.
    """

    results: tuple[DeliberationResult, ...]
    winner_id: str
    duration_ms: int

    def __post_init__(self) -> None:
        """Validate response (fail-fast)."""
        if not self.results:
            raise ValueError("results cannot be empty")

        if not self.winner_id or not self.winner_id.strip():
            raise ValueError("winner_id cannot be empty")

        if self.duration_ms < 0:
            raise ValueError(f"duration_ms must be >= 0, got {self.duration_ms}")

    def get_winner(self) -> DeliberationResult:
        """
        Get the winning deliberation result.

        Returns:
            DeliberationResult with author_id matching winner_id

        Raises:
            ValueError: If winner_id not found in results
        """
        for result in self.results:
            if result.proposal.author_id == self.winner_id:
                return result

        raise ValueError(f"Winner {self.winner_id} not found in results")

    def get_winner_content(self) -> str:
        """
        Get the winning proposal content (convenience method).

        Returns:
            Content of the winning proposal
        """
        winner = self.get_winner()
        return winner.proposal.content


class OrchestratorPort(Protocol):
    """
    Port (interface) for Orchestrator Service integration.

    Responsibilities:
    - Submit deliberation requests to Orchestrator (fire-and-forget)
    - Return deliberation tracking ID immediately
    - Results handled asynchronously via NATS consumer

    Implementation:
    - Infrastructure layer provides concrete adapter (gRPC client)
    - Use cases depend on this interface (not concrete implementation)

    Design Pattern: Fire-and-Forget
    - deliberate() returns immediately with DeliberationId (~30ms)
    - Orchestrator executes asynchronously in Ray cluster
    - Results published to NATS (backlog.review.result)
    - BacklogReviewResultConsumer processes results
    """

    async def deliberate(
        self,
        request: DeliberationRequest,
    ) -> DeliberationId:
        """
        Submit deliberation request to Orchestrator (fire-and-forget).

        This method submits a multi-agent deliberation request and returns
        immediately with a tracking ID. The actual deliberation happens
        asynchronously in the Ray cluster.

        Results are published to NATS and handled by BacklogReviewResultConsumer.

        Args:
            request: Deliberation request with task description, role, constraints

        Returns:
            DeliberationId for tracking the async deliberation

        Raises:
            OrchestratorError: If submission fails (network, validation, etc.)
        """
        ...


class OrchestratorError(Exception):
    """Base exception for Orchestrator Service errors."""

    pass

