"""OrchestratorPort - Interface for Orchestrator Service integration.

This port defines the contract for coordinating multi-agent deliberations
via the Orchestrator Service.

Following Hexagonal Architecture:
- Port (interface) lives in application layer
- Adapter (implementation) lives in infrastructure layer
- Domain layer knows nothing about Orchestrator
"""

from dataclasses import dataclass
from typing import Protocol


@dataclass(frozen=True)
class TaskConstraints:
    """
    Constraints and requirements for task execution.

    Domain Invariants:
    - rubric can be empty (no specific rubric)
    - requirements is a tuple of strings (can be empty)
    - metadata is optional
    - timeout_seconds must be > 0 if specified
    """

    rubric: str = ""
    requirements: tuple[str, ...] = ()
    metadata: dict[str, str] | None = None
    max_iterations: int = 3
    timeout_seconds: int = 180

    def __post_init__(self) -> None:
        """
        Validate constraints (fail-fast).

        Raises:
            ValueError: If validation fails
        """
        if self.timeout_seconds <= 0:
            raise ValueError(f"timeout_seconds must be > 0, got {self.timeout_seconds}")

        if self.max_iterations <= 0:
            raise ValueError(f"max_iterations must be > 0, got {self.max_iterations}")


@dataclass(frozen=True)
class DeliberationRequest:
    """
    Request for multi-agent deliberation.

    Domain Invariants:
    - task_description cannot be empty
    - role must be valid (ARCHITECT, QA, DEVOPS, DEV, DATA)
    - rounds must be >= 1
    - num_agents must be >= 1
    """

    task_description: str
    role: str  # ARCHITECT, QA, DEVOPS, DEV, DATA
    constraints: TaskConstraints | None = None
    rounds: int = 1
    num_agents: int = 3

    def __post_init__(self) -> None:
        """
        Validate request (fail-fast).

        Raises:
            ValueError: If validation fails
        """
        if not self.task_description or not self.task_description.strip():
            raise ValueError("task_description cannot be empty")

        valid_roles = ("ARCHITECT", "QA", "DEVOPS", "DEV", "DATA")
        if self.role not in valid_roles:
            raise ValueError(
                f"Invalid role: {self.role}. Must be one of {valid_roles}"
            )

        if self.rounds < 1:
            raise ValueError(f"rounds must be >= 1, got {self.rounds}")

        if self.num_agents < 1:
            raise ValueError(f"num_agents must be >= 1, got {self.num_agents}")


@dataclass(frozen=True)
class Proposal:
    """
    Proposal generated by an agent during deliberation.

    Represents a single agent's solution/recommendation.
    """

    author_id: str
    author_role: str
    content: str
    created_at_ms: int
    revisions: tuple[str, ...] = ()

    def __post_init__(self) -> None:
        """Validate proposal (fail-fast)."""
        if not self.author_id or not self.author_id.strip():
            raise ValueError("author_id cannot be empty")

        if not self.content or not self.content.strip():
            raise ValueError("content cannot be empty")

        if self.created_at_ms < 0:
            raise ValueError(f"created_at_ms must be >= 0, got {self.created_at_ms}")


@dataclass(frozen=True)
class DeliberationResult:
    """
    Result of a single agent's deliberation (proposal + evaluation).

    Contains the proposal, whether checks passed, score, and rank.
    """

    proposal: Proposal
    checks_passed: bool
    score: float
    rank: int

    def __post_init__(self) -> None:
        """Validate result (fail-fast)."""
        if self.score < 0.0 or self.score > 1.0:
            raise ValueError(f"score must be 0.0-1.0, got {self.score}")

        if self.rank < 1:
            raise ValueError(f"rank must be >= 1, got {self.rank}")


@dataclass(frozen=True)
class DeliberationResponse:
    """
    Response from Orchestrator deliberation.

    Contains all ranked proposals from the deliberation,
    the winner ID, and execution metadata.
    """

    results: tuple[DeliberationResult, ...]
    winner_id: str
    duration_ms: int

    def __post_init__(self) -> None:
        """Validate response (fail-fast)."""
        if not self.results:
            raise ValueError("results cannot be empty")

        if not self.winner_id or not self.winner_id.strip():
            raise ValueError("winner_id cannot be empty")

        if self.duration_ms < 0:
            raise ValueError(f"duration_ms must be >= 0, got {self.duration_ms}")

    def get_winner(self) -> DeliberationResult:
        """
        Get the winning deliberation result.

        Returns:
            DeliberationResult with author_id matching winner_id

        Raises:
            ValueError: If winner_id not found in results
        """
        for result in self.results:
            if result.proposal.author_id == self.winner_id:
                return result

        raise ValueError(f"Winner {self.winner_id} not found in results")

    def get_winner_content(self) -> str:
        """
        Get the winning proposal content (convenience method).

        Returns:
            Content of the winning proposal
        """
        winner = self.get_winner()
        return winner.proposal.content


class OrchestratorPort(Protocol):
    """
    Port (interface) for Orchestrator Service integration.

    Responsibilities:
    - Coordinate multi-agent deliberations
    - Submit deliberation requests to Orchestrator
    - Return ranked proposals with winner selection

    Implementation:
    - Infrastructure layer provides concrete adapter (gRPC client)
    - Use cases depend on this interface (not concrete implementation)
    """

    async def deliberate(
        self,
        request: DeliberationRequest,
    ) -> DeliberationResponse:
        """
        Execute multi-agent deliberation for a task.

        This method coordinates peer review between multiple agents
        of the same role, producing ranked proposals with a selected winner.

        Args:
            request: Deliberation request with task description, role, constraints

        Returns:
            DeliberationResponse with ranked results and winner

        Raises:
            OrchestratorError: If deliberation fails (network, timeout, etc.)
        """
        ...


class OrchestratorError(Exception):
    """Base exception for Orchestrator Service errors."""

    pass

