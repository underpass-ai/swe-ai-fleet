# Planning Service - Architecture

**Bounded Context**: Planning
**Pattern**: DDD + Hexagonal Architecture
**Version**: v0.1.0

---

## üéØ Responsibility

Manage user story lifecycle with FSM (Finite State Machine) and decision approval workflow.

**Core Responsibilities**:
1. **Create and persist entities** in hierarchy: Project ‚Üí Epic ‚Üí Story ‚Üí Task
2. **Enforce domain invariants**: Task MUST belong to Story, Story MUST belong to Epic, Epic MUST belong to Project
3. **Manage user story lifecycle** with FSM (DRAFT ‚Üí PO_REVIEW ‚Üí READY ‚Üí IN_PROGRESS ‚Üí DONE)
4. **Decision approval/rejection workflow** (PO human-in-the-loop)
5. **Task Derivation**: Store tasks created by vLLM and validate them before story can proceed
6. **Publish domain events** for orchestrator integration

**Task Derivation Flow**:
- **vLLM creates tasks** ‚Üí LLM generates tasks from approved Plan
- **Planning stores tasks** ‚Üí Planning Service persists tasks generated by vLLM
- **Validation** ‚Üí Planning Service validates tasks (priorities, completeness)
- **Human-in-the-loop** ‚Üí PO decides if tasks are correct/valid
- **Story validation** ‚Üí Story can only transition to READY_FOR_EXECUTION if all tasks are valid

---

## üèó Hexagonal Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   Domain Layer                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  Entities                                      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    Project (Root)                              ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    Epic (Groups Stories)                       ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    Story (Aggregate Root)                      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    Task (Atomic Work Unit)                     ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                                                ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  Value Objects                                 ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    ProjectId, EpicId, StoryId, TaskId         ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    StoryState, DORScore, Title, Brief          ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    PlanId (used in events, NOT persisted)      ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì                       ‚Üë
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                Application Layer                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  Ports (Interfaces)                            ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    StoragePort, MessagingPort                  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                                                ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  Use Cases                                     ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    Project: CreateProject, GetProject, ListProjects ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    Epic: CreateEpic, GetEpic, ListEpics       ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    Story: CreateStory, TransitionStory, ListStories ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    Task: CreateTask, GetTask, ListTasks        ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    Task Derivation: DeriveTasksFromPlan        ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    Decision: ApproveDecision, RejectDecision  ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì                       ‚Üë
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Infrastructure Layer                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  Adapters (Implementations)                    ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    Neo4jAdapter     - Graph structure          ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    ValkeyAdapter    - Permanent details        ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    StorageAdapter   - Composite (Neo4j+Valkey) ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    NATSAdapter      - Event publishing         ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    RayExecutorAdapter - Task derivation (vLLM) ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    gRPC Server      - External API             ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                                                ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  Consumers (Event-Driven)                      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    PlanApprovedConsumer - planning.plan.approved ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    TaskDerivationResultConsumer - agent.response.completed ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üíæ Dual Persistence Pattern

### Why Dual Storage?

**Neo4j (Graph) + Valkey (Details)** provide complementary capabilities:

| Aspect | Neo4j | Valkey |
|--------|-------|--------|
| **Purpose** | Knowledge graph structure | Detailed content storage |
| **Stores** | Nodes (id, state) + Relationships | Full story data (Hash) |
| **Queries** | Graph traversal, rehydration | Fast key-value lookups |
| **Use Cases** | Navigate alternatives, observability | CRUD operations, FSM |
| **Persistence** | Native (always persistent) | AOF + RDB snapshots |

---

### Neo4j: Graph Structure (Observability + Rehydration)

**What it stores**:
```cypher
// Story node (minimal properties)
(:Story {id: "s-uuid", state: "DRAFT"})

// Relationships
(:User {id: "po-001"})-[:CREATED]->(:Story {id: "s-001"})
(:Story {id: "s-001"})-[:HAS_TASK]->(:Task {id: "t-001"})
(:Decision {id: "d-001"})-[:AFFECTS]->(:Task {id: "t-001"})
(:Decision {id: "d-002"})-[:ALTERNATIVE_OF]->(:Decision {id: "d-001"})
```

**Enables**:
1. **Rehydration**: From any node, traverse graph to rebuild context
2. **Alternative Solutions**: Query decisions with `[:ALTERNATIVE_OF]` relationships
3. **Observability**: Visualize complete project graph
4. **Auditing**: Who created what, when, and how

**Example Query** (Rehydrate context from Story X):
```cypher
MATCH (s:Story {id: $story_id})
OPTIONAL MATCH (s)-[:HAS_TASK]->(t:Task)
OPTIONAL MATCH (d:Decision)-[:AFFECTS]->(t)
OPTIONAL MATCH (alt:Decision)-[:ALTERNATIVE_OF]->(d)
RETURN s, collect(DISTINCT t) AS tasks,
       collect(DISTINCT d) AS decisions,
       collect(DISTINCT alt) AS alternatives
```

---

### Valkey: Permanent Details Storage

**What it stores**:
```
// Full story details as Hash (permanent, no TTL)
planning:story:s-001 ‚Üí Hash {
  story_id: "s-001",
  title: "As a user, I want authentication",
  brief: "Implement JWT with refresh tokens...",
  state: "DRAFT",
  dor_score: "85",
  created_by: "po-001",
  created_at: "2025-11-02T10:00:00Z",
  updated_at: "2025-11-02T11:30:00Z"
}

// FSM state for fast lookups
planning:story:s-001:state ‚Üí String "DRAFT"

// Indexing sets
planning:stories:all ‚Üí Set {"s-001", "s-002", "s-003"}
planning:stories:state:DRAFT ‚Üí Set {"s-001", "s-003"}
planning:stories:state:IN_PROGRESS ‚Üí Set {"s-002"}
```

**Persistence Configuration** (K8s ConfigMap):
```yaml
# valkey.conf
appendonly yes           # Enable AOF (Append-Only File)
appendfsync everysec     # Sync every second (balance performance/safety)
save 900 1               # RDB snapshot: after 900s if 1 change
save 300 10              # RDB snapshot: after 300s if 10 changes
save 60 10000            # RDB snapshot: after 60s if 10000 changes
```

**Benefits**:
- ‚úÖ Permanent storage (survives pod restarts)
- ‚úÖ Fast reads (in-memory with disk persistence)
- ‚úÖ Efficient indexing (Sets for state filtering)
- ‚úÖ No TTL (data never expires)

---

## üîÑ Data Flow

### Write Path (Create Story)

```
1. Client calls gRPC CreateStory()
   ‚Üì
2. CreateStoryUseCase.execute()
   ‚Üì
3. Create Story entity (domain validation)
   ‚Üì
4. StorageAdapter.save_story()
   ‚îú‚îÄ‚Üí ValkeyAdapter: Save Hash with all details (permanent)
   ‚îî‚îÄ‚Üí Neo4jAdapter: Create node with (id, state) + CREATED_BY relationship
   ‚Üì
5. NATSAdapter: Publish story.created event
   ‚Üì
6. Return Story to client
```

### Read Path (Get Story)

```
1. Client calls gRPC GetStory(id)
   ‚Üì
2. StorageAdapter.get_story(id)
   ‚Üì
3. ValkeyAdapter: HGETALL planning:story:{id}
   ‚Üì
4. Convert Hash ‚Üí Story entity
   ‚Üì
5. Return Story to client
```

### Graph Query Path (Rehydration)

```
1. Context Service needs to rehydrate from Story X
   ‚Üì
2. Query Neo4j:
   MATCH (s:Story {id: "s-001"})-[:HAS_TASK]->(t:Task)
   OPTIONAL MATCH (d:Decision)-[:AFFECTS]->(t)
   RETURN s.id, collect(t.id) AS task_ids, collect(d.id) AS decision_ids
   ‚Üì
3. For each ID (task, decision):
   Get details from Valkey: HGETALL planning:task:{id}
   ‚Üì
4. Assemble complete context with relationships
   ‚Üì
5. Return enriched context
```

---

## üß© Domain Model

### Hierarchy: Project ‚Üí Epic ‚Üí Story ‚Üí Task

**Business Rule (Domain Invariants)**:
- ‚úÖ **Task MUST belong to a Story** (`task.story_id` is REQUIRED)
- ‚úÖ **Story MUST belong to an Epic** (`story.epic_id` is REQUIRED)
- ‚úÖ **Epic MUST belong to a Project** (`epic.project_id` is REQUIRED)
- ‚úÖ **Project is the root** (no parent)

**Planning Service Responsibility**:
- ‚úÖ Creates and persists all entities in this hierarchy
- ‚úÖ Enforces domain invariants (fail-fast validation)
- ‚úÖ Manages lifecycle of all entities

**Note on Plan (Agile Iteration/Sprint)**:
- ‚ö†Ô∏è **Plan is NOT a persisted entity** in Planning Service
- **Plan = PO's decision on which Stories to work on in the next iteration**
- **Plan = Sprint/Iteration** that contains the User Stories selected by PO
- Plan is created/approved by PO (Product Owner) - human-in-the-loop decision
- Plan information comes from `planning.plan.approved` event (from another service)
- Planning Service uses Plan data from the event to derive Tasks for Stories in the Plan
- In agile context: **Plan (PO's Sprint selection) ‚Üí Stories ‚Üí Tasks**
- Plan represents the set of User Stories that PO decided will be executed in the next agile iteration

### Project (Root Entity)

```python
@dataclass(frozen=True)
class Project:
    project_id: ProjectId
    name: str
    description: str = ""
    status: ProjectStatus = ProjectStatus.ACTIVE
    owner: str = ""
    created_at: datetime  # REQUIRED
    updated_at: datetime  # REQUIRED
```

**Domain Invariants**:
- ‚úÖ Name cannot be empty
- ‚úÖ Project is root (no parent)
- ‚úÖ All dataclasses are frozen (immutable)

### Epic (Groups Stories)

```python
@dataclass(frozen=True)
class Epic:
    epic_id: EpicId
    project_id: ProjectId  # REQUIRED - domain invariant
    title: str
    description: str = ""
    status: EpicStatus = EpicStatus.ACTIVE
    created_at: datetime  # REQUIRED
    updated_at: datetime  # REQUIRED
```

**Domain Invariants**:
- ‚úÖ Title cannot be empty
- ‚úÖ **MUST belong to a Project** (`project_id` is REQUIRED)
- ‚úÖ All dataclasses are frozen (immutable)

### Story (Aggregate Root)

```python
@dataclass(frozen=True)
class Story:
    story_id: StoryId
    epic_id: EpicId  # REQUIRED - domain invariant
    title: Title
    brief: Brief
    state: StoryState        # FSM state
    dor_score: DORScore      # Definition of Ready (0-100)
    created_by: UserName
    created_at: datetime
    updated_at: datetime

    def transition_to(self, target_state: StoryState) -> Story:
        """Immutable state transition (returns new instance)."""
        ...

    def meets_dor_threshold(self) -> bool:
        """Check if DoR score >= 80."""
        return self.dor_score.is_ready()

    def can_be_planned(self) -> bool:
        """Check if story can be planned now (DoR + state check)."""
        return (
            self.meets_dor_threshold()
            and self.state.value == StoryStateEnum.READY_FOR_PLANNING
        )

    def is_planned_or_beyond(self) -> bool:
        """Business rule: DoR >= 80 AND state >= READY_FOR_PLANNING."""
        ...
```

**Domain Invariants** (fail-fast validation):
- ‚úÖ Title and brief cannot be empty
- ‚úÖ **MUST belong to an Epic** (`epic_id` is REQUIRED)
- ‚úÖ State transitions must follow FSM rules
- ‚úÖ DoR score must be 0-100
- ‚úÖ created_at cannot be after updated_at
- ‚úÖ All dataclasses are frozen (immutable)

### Task (Atomic Work Unit)

```python
@dataclass(frozen=True)
class Task:
    task_id: TaskId  # Planning Service generates
    story_id: StoryId  # REQUIRED - domain invariant (Task belongs to Story)
    plan_id: PlanId  # Optional - reference to Plan (Sprint/Iteration) from event
    title: str  # From vLLM
    description: str = ""  # From vLLM
    estimated_hours: int = 0  # From vLLM
    assigned_to: str = ""  # Planning Service assigns (RBAC)
    type: TaskType = TaskType.DEVELOPMENT
    status: TaskStatus = TaskStatus.TODO
    priority: int = 1  # From vLLM
    created_at: datetime  # REQUIRED
    updated_at: datetime  # REQUIRED
```

**Domain Invariants** (fail-fast validation):
- ‚úÖ Title cannot be empty
- ‚úÖ **MUST belong to a Story** (`story_id` is REQUIRED)
- ‚úÖ `plan_id` is optional reference to Plan (Sprint/Iteration) - Plan is NOT persisted in Planning Service
- ‚úÖ estimated_hours cannot be negative
- ‚úÖ priority must be >= 1
- ‚úÖ created_at and updated_at are REQUIRED
- ‚úÖ All dataclasses are frozen (immutable)

**Agile Context**:
- **Plan = PO's decision** on which Stories to work on in the next iteration (Sprint)
- **Plan = Sprint/Iteration** selected by PO (contains multiple Stories)
- **Story** (contains multiple Tasks)
- **Task** belongs to Story, Story belongs to Epic, Epic belongs to Project
- Plan is created/approved by PO (human-in-the-loop) and managed by another service
- Planning Service only references Plan via `plan_id` from events


### FSM (Finite State Machine)

```
Normal Flow:
DRAFT ‚Üí PO_REVIEW ‚Üí READY_FOR_PLANNING ‚Üí PLANNED ‚Üí READY_FOR_EXECUTION ‚Üí
IN_PROGRESS ‚Üí CODE_REVIEW ‚Üí TESTING ‚Üí READY_TO_REVIEW ‚Üí ACCEPTED ‚Üí DONE ‚Üí ARCHIVED

Sprint Closure:
READY_FOR_EXECUTION/IN_PROGRESS/CODE_REVIEW/TESTING/READY_TO_REVIEW ‚Üí CARRY_OVER ‚Üí
[DRAFT | READY_FOR_EXECUTION | ARCHIVED]

Note: PLANNED is NOT carried over (tasks derived but not committed to sprint)

States Explained:
- DRAFT: Story created, initial state
- PO_REVIEW: Awaiting Product Owner review and approval for scope
- READY_FOR_PLANNING: PO approved scope, ready for task derivation
- PLANNED: Tasks have been derived (story‚Üítasks decomposition done)
- READY_FOR_EXECUTION: Tasks assigned and queued, waiting for agent pickup
- IN_PROGRESS: Agent actively executing tasks
- CODE_REVIEW: Technical code review by architect/peer agents
- TESTING: Automated testing and validation phase
- READY_TO_REVIEW: Tests passed, awaiting final PO/QA examination
- ACCEPTED: PO/QA accepted the work (story functionally complete, sprint ongoing)
- CARRY_OVER: Sprint ended with story incomplete, requires reevaluation and re-estimation
- DONE: Sprint/agile cycle finished (formal closure, story closed)
- ARCHIVED: Story archived (terminal state)

Sprint Closure Handling:
- Stories in ACCEPTED ‚Üí transition to DONE when sprint ends (normal completion)
- Stories committed to sprint (READY_FOR_EXECUTION, IN_PROGRESS, CODE_REVIEW,
  TESTING, READY_TO_REVIEW) ‚Üí transition to CARRY_OVER when sprint ends (incomplete work)
- Stories NOT committed yet (DRAFT, PO_REVIEW, READY_FOR_PLANNING, PLANNED) ‚Üí
  stay in current state (not affected by sprint closure)
- From CARRY_OVER, PO decides:
  * CARRY_OVER ‚Üí DRAFT: Reevaluate requirements, repuntuar DoR score
  * CARRY_OVER ‚Üí READY_FOR_EXECUTION: Continue as-is in next sprint
  * CARRY_OVER ‚Üí ARCHIVED: Cancel/deprioritize story

Alternative flows:
- Any state ‚Üí DRAFT (reset/restart)
- PO_REVIEW ‚Üí DRAFT (scope rejection by PO)
- CODE_REVIEW ‚Üí IN_PROGRESS (code rejected, rework needed)
- TESTING ‚Üí IN_PROGRESS (tests failed, rework needed)
- READY_TO_REVIEW ‚Üí IN_PROGRESS (PO/QA rejected final result, rework needed)
```

---

## üì° Integration

### Consumes (NATS Events)

| Event | Subject | Purpose | Handler |
|-------|---------|---------|---------|
| **plan.approved** | `planning.plan.approved` | Trigger task derivation | `PlanApprovedConsumer` |
| **agent.response.completed** | `agent.response.completed` | Process task derivation results from vLLM | `TaskDerivationResultConsumer` |

**Note**: Planning Service consumes events for task derivation workflow (vLLM creates tasks, Planning stores them).

### Produces (NATS Events)

| Event | Subject | Payload | Consumer |
|-------|---------|---------|----------|
| **story.created** | `planning.story.created` | {story_id, title, created_by} | Orchestrator, Context |
| **story.transitioned** | `planning.story.transitioned` | {story_id, from_state, to_state} | Orchestrator, Context |
| **story.tasks_not_ready** | `planning.story.tasks_not_ready` | {story_id, reason, task_ids_without_priority, total_tasks} | PO-UI (human-in-the-loop) |
| **task.created** | `planning.task.created` | {task_id, story_id, plan_id, ...} | Orchestrator, Context |
| **tasks.derived** | `planning.tasks.derived` | {plan_id, task_count, timestamp} | Monitoring |
| **task.derivation.failed** | `planning.task.derivation.failed` | {plan_id, reason, requires_manual_review} | PO-UI |
| **decision.approved** | `planning.decision.approved` | {story_id, decision_id, approved_by} | Orchestrator (triggers execution) |
| **decision.rejected** | `planning.decision.rejected` | {story_id, decision_id, reason} | Orchestrator (triggers re-deliberation) |

---

## üîå External Dependencies

- **Neo4j**: Graph database (bolt://neo4j:7687)
- **Valkey**: Permanent storage (redis://valkey:6379)
- **NATS JetStream**: Event streaming (nats://nats:4222)

**Dependencies**:
- **Ray Executor Service** (gRPC): For task derivation (vLLM execution)
  - Planning Service sends Plan to Ray Executor
  - Ray Executor executes vLLM and generates tasks
  - Results come back via NATS (`agent.response.completed`)

**No dependencies on other bounded contexts** (core/context, core/memory, etc.)

---

## ‚úÖ DDD Compliance Checklist

- ‚úÖ **No reflection** (`setattr`, `object.__setattr__`, `__dict__`)
- ‚úÖ **No dynamic mutation** (all dataclasses frozen)
- ‚úÖ **Fail-fast validation** (ValueError in `__post_init__`)
- ‚úÖ **No to_dict/from_dict in domain** (mappers in infrastructure)
- ‚úÖ **Dependency injection** (use cases receive ports via constructor)
- ‚úÖ **Immutability** (builder methods return new instances)
- ‚úÖ **Type hints complete** (all functions, methods, parameters)
- ‚úÖ **Layer boundaries respected** (domain ‚Üí application ‚Üí infrastructure)
- ‚úÖ **Bounded context isolation** (no imports from core/*)

---

## üîÑ Task Derivation Workflow

### Overview

**Task Derivation** is the process where:
1. **vLLM creates tasks** from an approved Plan
2. **Planning Service stores tasks** generated by vLLM
3. **Planning Service validates tasks** (priorities, completeness)
4. **PO decides if tasks are correct** (human-in-the-loop)
5. **Story can only advance** to READY_FOR_EXECUTION if all tasks are valid

### Flow Diagram

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    TASK DERIVATION FLOW                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

1. PO (Product Owner) decides which Stories to work on in next iteration
   ‚Üì
2. Plan Approved (PO's Sprint selection decision)
   ‚Üì
3. Event: planning.plan.approved (Plan contains selected Stories)
   ‚Üì
       4. PlanApprovedConsumer ‚Üí DeriveTasksFromPlanUseCase
          ‚Üì
       5. DeriveTasksFromPlanUseCase:
          - Receives Plan (PO's Sprint selection) approval event
          - Plan contains Stories selected by PO for next iteration
          - For each Story in Plan, extracts Story data from event
          - Builds LLM prompt (Story description + acceptance criteria + technical notes)
          - Sends to Ray Executor (async, fire-and-forget) to derive Tasks for Story
   ‚Üì
6. Ray Executor ‚Üí vLLM (GPU worker)
   ‚Üì
7. vLLM generates tasks (structured output):
   TITLE: Setup project structure
   DESCRIPTION: Create initial project folders
   ESTIMATED_HOURS: 8
   PRIORITY: 1
   KEYWORDS: setup, project
   ---
   (more tasks...)
   ‚Üì
8. Event: agent.response.completed (with LLM result)
   ‚Üì
9. TaskDerivationResultConsumer ‚Üí TaskDerivationResultService
   ‚Üì
       10. TaskDerivationResultService:
          - Receives plan_id from event (Plan = Sprint/Iteration, NOT persisted)
          - Extracts story_id from event (Story belongs to Plan/Sprint)
          - Parses LLM output ‚Üí TaskNode VOs (Tasks for the Story)
          - Builds dependency graph (from keywords)
          - Validates circular dependencies
          - Generates real TaskIds (Planning Service, NOT from LLM)
          - Stores tasks in Neo4j + Valkey (tasks belong to Story, plan_id references Sprint)
          - Stores dependency relationships
   ‚Üì
11. Tasks stored in Planning Service
    ‚Üì
12. PO validates tasks (via UI):
    - Checks if tasks are correct
    - Can reformulate story if needed
    - Can request re-derivation
    ‚Üì
13. Story transition to READY_FOR_EXECUTION:
    - Validates: All tasks have priority >= 1
    - If invalid ‚Üí StoryTasksNotReadyEvent ‚Üí PO notified
    - If valid ‚Üí Story transitions ‚Üí READY_FOR_EXECUTION
```

### Responsibilities

**vLLM (Ray Executor)**:
- ‚úÖ Generates tasks for a Story (Story belongs to Plan/Sprint)
- ‚úÖ Receives Story data from Plan approval event
- ‚úÖ Outputs structured format (TITLE, DESCRIPTION, ESTIMATED_HOURS, PRIORITY, KEYWORDS)
- ‚úÖ Does NOT generate TaskIds (Planning Service generates them)

**Planning Service**:
- ‚úÖ Receives Plan (PO's Sprint selection decision) approval event (`planning.plan.approved`)
- ‚úÖ Plan contains Stories selected by PO for next iteration
- ‚úÖ For each Story in Plan, derives Tasks using vLLM
- ‚úÖ Stores tasks generated by vLLM (tasks belong to Story, Story belongs to Plan/Sprint)
- ‚úÖ Generates TaskIds (T-{uuid})
- ‚úÖ Validates tasks before story can advance
- ‚úÖ Notifies PO if tasks are invalid (human-in-the-loop)
- ‚úÖ Manages task dependencies (from keywords)

**PO (Human)**:
- ‚úÖ Reviews tasks generated by vLLM
- ‚úÖ Decides if tasks are correct/valid
- ‚úÖ Can reformulate story if tasks are incorrect
- ‚úÖ Approves story transition to READY_FOR_EXECUTION

### Validation Rules

**Before Story can transition to READY_FOR_EXECUTION**:

1. **Tasks must exist**: Story must have at least one task
2. **Priorities must be valid**: All tasks must have `priority >= 1` (defined by vLLM)
3. **No circular dependencies**: Dependency graph must be acyclic

**If validation fails**:
- `StoryTasksNotReadyEvent` published
- PO receives notification in UI
- Story CANNOT transition to READY_FOR_EXECUTION
- PO can reformulate story or request re-derivation

### Components

**Use Cases**:
- `DeriveTasksFromPlanUseCase`: Sends Plan to Ray Executor for task generation

**Application Services**:
- `TaskDerivationResultService`: Processes vLLM results and stores tasks

**Consumers**:
- `PlanApprovedConsumer`: Listens to `planning.plan.approved` ‚Üí triggers derivation
- `TaskDerivationResultConsumer`: Listens to `agent.response.completed` ‚Üí processes results

**Mappers**:
- `LLMTaskDerivationMapper`: Parses vLLM output ‚Üí TaskNode VOs

**Configuration**:
- `config/task_derivation.yaml`: LLM prompt template and constraints

### Known Issues

‚ö†Ô∏è **Current implementation has reliability issues**:
- LLM output parsing may fail (LLM is not idempotent)
- ROLE comes from LLM (should come from event according to audit)
- Dependency calculation based on keywords may be incorrect

**Status**: Under review - user indicates implementation is not reliable.

---

**Planning Service Architecture** - Following SWE AI Fleet architectural principles

