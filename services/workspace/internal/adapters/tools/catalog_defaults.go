package tools

import (
	"encoding/json"

	"github.com/underpass-ai/swe-ai-fleet/services/workspace/internal/domain"
)

func DefaultCapabilities() []domain.Capability {
	return []domain.Capability{
		{
			Name:             "fs.list",
			Description:      "List files/directories under the session workspace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"recursive":{"type":"boolean"},"max_entries":{"type":"integer","minimum":1,"maximum":1000}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"entries":{"type":"array"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 15, MaxRetries: 0, OutputLimitKB: 256},
			Preconditions:    []string{"path must be inside allowed_paths"},
			Postconditions:   []string{"no file system mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "fs.list"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","recursive":false}`),
			},
		},
		{
			Name:             "fs.read_file",
			Description:      "Read a text or binary file from workspace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576}},"required":["path"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"content":{"type":"string"},"encoding":{"type":"string"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"path must be inside allowed_paths and point to a regular file"},
			Postconditions:   []string{"no file system mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "fs.read_file"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":"README.md"}`),
			},
		},
		{
			Name:             "fs.write_file",
			Description:      "Write a file in workspace using UTF-8 or base64 payload.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"content":{"type":"string"},"encoding":{"type":"string","enum":["utf8","base64"]},"create_parents":{"type":"boolean"}},"required":["path","content"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"bytes_written":{"type":"integer"},"sha256":{"type":"string"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 256},
			Preconditions:    []string{"path must be inside allowed_paths"},
			Postconditions:   []string{"target file updated"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "fs.write_file"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":"notes/todo.txt","content":"hello","create_parents":true}`),
			},
		},
		{
			Name:             "fs.patch",
			Description:      "Apply a unified diff patch to files in the workspace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"unified_diff":{"type":"string"},"strategy":{"type":"string","enum":["apply","reject_on_conflict"]}},"required":["unified_diff"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"applied":{"type":"boolean"},"strategy":{"type":"string"},"changed_paths":{"type":"array","items":{"type":"string"}},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 45, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"patch paths must be inside allowed_paths"},
			Postconditions:   []string{"workspace files may change"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "fs.patch"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"unified_diff":"diff --git a/file b/file\n...","strategy":"reject_on_conflict"}`),
			},
		},
		{
			Name:             "fs.search",
			Description:      "Search file contents using regex pattern.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"pattern":{"type":"string"},"max_results":{"type":"integer","minimum":1,"maximum":2000}},"required":["pattern"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"matches":{"type":"array"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 512},
			Preconditions:    []string{"path must be inside allowed_paths"},
			Postconditions:   []string{"no file system mutation"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "fs.search"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","pattern":"TODO","max_results":50}`),
			},
		},
		{
			Name:             "conn.list_profiles",
			Description:      "List governable external connection profiles visible to the session principal.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profiles":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string"},"kind":{"type":"string"},"description":{"type":"string"},"read_only":{"type":"boolean"},"scopes":{"type":"object"}}}},"count":{"type":"integer"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 10, MaxRetries: 0, OutputLimitKB: 256},
			Preconditions:    []string{"session metadata may restrict allowed profiles"},
			Postconditions:   []string{"no state mutation"},
			CostHint:         "low",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "conn.list_profiles"},
			Examples: []json.RawMessage{
				mustRawJSON(`{}`),
			},
		},
		{
			Name:             "conn.describe_profile",
			Description:      "Describe a specific connection profile (without exposing credentials).",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"}},"required":["profile_id"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile":{"type":"object","properties":{"id":{"type":"string"},"kind":{"type":"string"},"description":{"type":"string"},"read_only":{"type":"boolean"},"scopes":{"type":"object"}}}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 10, MaxRetries: 0, OutputLimitKB: 128},
			Preconditions:    []string{"profile_id must refer to a visible profile"},
			Postconditions:   []string{"no state mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "conn.describe_profile"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.redis"}`),
			},
		},
		{
			Name:             "nats.request",
			Description:      "Send NATS request/reply call with profile-governed subject limits.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"subject":{"type":"string"},"payload":{"type":"string"},"payload_encoding":{"type":"string","enum":["utf8","base64"]},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576}},"required":["profile_id","subject"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"subject":{"type":"string"},"response_base64":{"type":"string"},"response_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"profile_id and subject must be allowlisted"},
			Postconditions:   []string{"request-reply interaction completed"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				SubjectFields: []domain.PolicySubjectField{{Field: "subject"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "nats.request"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.nats","subject":"sandbox.echo","payload":"hello","payload_encoding":"utf8","timeout_ms":2000}`),
			},
		},
		{
			Name:             "nats.subscribe_pull",
			Description:      "Pull messages from NATS subject with deterministic limits.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"subject":{"type":"string"},"max_messages":{"type":"integer","minimum":1,"maximum":100},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","subject"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"subject":{"type":"string"},"messages":{"type":"array","items":{"type":"object","properties":{"subject":{"type":"string"},"data_base64":{"type":"string"},"size_bytes":{"type":"integer"},"data_trimmed":{"type":"boolean"}}}},"message_count":{"type":"integer"},"total_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"profile_id and subject must be allowlisted"},
			Postconditions:   []string{"bounded message batch returned"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				SubjectFields: []domain.PolicySubjectField{{Field: "subject"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "nats.subscribe_pull"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.nats","subject":"sandbox.events","max_messages":20,"timeout_ms":2000}`),
			},
		},
		{
			Name:             "kafka.consume",
			Description:      "Consume Kafka messages from an allowlisted topic with bounded output.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"topic":{"type":"string"},"partition":{"type":"integer","minimum":0},"offset":{"type":"string","enum":["earliest","latest"]},"max_messages":{"type":"integer","minimum":1,"maximum":200},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","topic"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"topic":{"type":"string"},"messages":{"type":"array","items":{"type":"object","properties":{"partition":{"type":"integer"},"offset":{"type":"integer"},"timestamp_unix":{"type":"integer"},"key_base64":{"type":"string"},"value_base64":{"type":"string"},"size_bytes":{"type":"integer"},"key_trimmed":{"type":"boolean"},"value_trimmed":{"type":"boolean"}}}},"message_count":{"type":"integer"},"total_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"profile_id and topic must be allowlisted"},
			Postconditions:   []string{"bounded message batch returned"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				TopicFields:   []domain.PolicyTopicField{{Field: "topic"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "kafka.consume"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.kafka","topic":"sandbox.events","partition":0,"offset":"latest","max_messages":20,"timeout_ms":2000}`),
			},
		},
		{
			Name:             "kafka.topic_metadata",
			Description:      "Describe Kafka topic metadata for an allowlisted topic.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"topic":{"type":"string"}},"required":["profile_id","topic"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"topic":{"type":"string"},"partition_count":{"type":"integer"},"partitions":{"type":"array","items":{"type":"object","properties":{"partition":{"type":"integer"},"leader_host":{"type":"string"},"leader_port":{"type":"integer"},"replica_ids":{"type":"array","items":{"type":"integer"}},"isr_ids":{"type":"array","items":{"type":"integer"}},"replica_count":{"type":"integer"},"isr_count":{"type":"integer"}}}}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 512},
			Preconditions:    []string{"profile_id and topic must be allowlisted"},
			Postconditions:   []string{"no state mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				TopicFields:   []domain.PolicyTopicField{{Field: "topic"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "kafka.topic_metadata"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.kafka","topic":"sandbox.events"}`),
			},
		},
		{
			Name:             "rabbit.consume",
			Description:      "Consume RabbitMQ messages from an allowlisted queue with bounded output.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"queue":{"type":"string"},"max_messages":{"type":"integer","minimum":1,"maximum":200},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","queue"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"queue":{"type":"string"},"messages":{"type":"array","items":{"type":"object","properties":{"exchange":{"type":"string"},"routing_key":{"type":"string"},"redelivered":{"type":"boolean"},"timestamp_unix":{"type":"integer"},"body_base64":{"type":"string"},"size_bytes":{"type":"integer"},"body_trimmed":{"type":"boolean"}}}},"message_count":{"type":"integer"},"total_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"profile_id and queue must be allowlisted"},
			Postconditions:   []string{"bounded message batch returned"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				QueueFields:   []domain.PolicyQueueField{{Field: "queue"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "rabbit.consume"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.rabbit","queue":"sandbox.jobs","max_messages":20,"timeout_ms":2000}`),
			},
		},
		{
			Name:             "rabbit.queue_info",
			Description:      "Inspect RabbitMQ queue metrics for an allowlisted queue.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"queue":{"type":"string"},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","queue"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"queue":{"type":"string"},"messages":{"type":"integer"},"consumers":{"type":"integer"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 256},
			Preconditions:    []string{"profile_id and queue must be allowlisted"},
			Postconditions:   []string{"no state mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				QueueFields:   []domain.PolicyQueueField{{Field: "queue"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "rabbit.queue_info"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.rabbit","queue":"sandbox.jobs"}`),
			},
		},
		{
			Name:             "git.status",
			Description:      "Run git status in the workspace repository.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"short":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"status":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 1, OutputLimitKB: 256},
			Preconditions:    []string{"workspace must contain a git repository"},
			Postconditions:   []string{"no repository mutation"},
			CostHint:         "low",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "git.status"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"short":true}`),
			},
		},
		{
			Name:             "git.diff",
			Description:      "Return unified diff from git workspace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"staged":{"type":"boolean"},"paths":{"type":"array","items":{"type":"string"}},"base":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"diff":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 1, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace must contain a git repository"},
			Postconditions:   []string{"no repository mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "paths", Multi: true, WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "git.diff"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"staged":false}`),
			},
		},
		{
			Name:             "git.apply_patch",
			Description:      "Apply a unified diff patch using git apply.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"patch":{"type":"string"},"check":{"type":"boolean"}},"required":["patch"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"applied":{"type":"boolean"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 45, MaxRetries: 0, OutputLimitKB: 512},
			Preconditions:    []string{"workspace must contain a git repository"},
			Postconditions:   []string{"working tree may change"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "git.apply_patch"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"patch":"diff --git ...","check":true}`),
			},
		},
		{
			Name:             "repo.detect_project_type",
			Description:      "Detect repository project type for build/test orchestration.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"flavor":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 15, MaxRetries: 0, OutputLimitKB: 64},
			Preconditions:    []string{"workspace must be initialized"},
			Postconditions:   []string{"no repository mutation"},
			CostHint:         "low",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "repo.detect_project_type"},
			Examples: []json.RawMessage{
				mustRawJSON(`{}`),
			},
		},
		{
			Name:             "repo.detect_toolchain",
			Description:      "Detect language toolchain metadata for orchestration.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"language":{"type":"string"},"build_system":{"type":"string"},"test_framework":{"type":"string"},"containerizable":{"type":"boolean"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 64},
			Preconditions:    []string{"workspace must be initialized"},
			Postconditions:   []string{"no repository mutation"},
			CostHint:         "low",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "repo.detect_toolchain"},
			Examples: []json.RawMessage{
				mustRawJSON(`{}`),
			},
		},
		{
			Name:             "repo.validate",
			Description:      "Run toolchain-aware repository validation (syntax/compile checks).",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"language":{"type":"string"},"build_system":{"type":"string"},"test_framework":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"diagnostics":{"type":"array","items":{"type":"string"}},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain a supported project type"},
			Postconditions:   []string{"validation output can be generated"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "repo.validate"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "repo.build",
			Description:      "Execute project build command with repository-aware defaults.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"extra_args":{"type":"array","items":{"type":"string"}}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 240, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain a supported project type"},
			Postconditions:   []string{"build artifacts may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				ArgFields: []domain.PolicyArgField{
					{
						Field:         "extra_args",
						Multi:         true,
						MaxItems:      8,
						MaxLength:     64,
						AllowedPrefix: []string{"-v", "-q", "-race", "-trimpath", "-tags=", "-cover", "-coverprofile=", "-run=", "-count=", "-timeout=", "--if-present", "--silent", "--maxfail=", "--disable-warnings", "--release", "--locked", "--offline", "--features=", "--all-features", "--no-default-features", "--package=", "--tests", "-P", "--no-daemon", "-D"},
						DeniedPrefix:  []string{"-exec", "-toolexec", "-mod=mod", "-modfile", "-buildmode=plugin", "-f", "--file", "--require", "--import", "--project-cache-dir"},
						DenyCharacters: []string{
							";", "|", "&", "`", "$(", ">", "<", "\n", "\r",
						},
					},
				},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "repo.build"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "repo.test",
			Description:      "Execute repository test suite (preferred alias of repo.run_tests).",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"extra_args":{"type":"array","items":{"type":"string"}}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain a supported project type"},
			Postconditions:   []string{"test reports can be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				ArgFields: []domain.PolicyArgField{
					{
						Field:         "extra_args",
						Multi:         true,
						MaxItems:      8,
						MaxLength:     64,
						AllowedPrefix: []string{"-v", "-q", "-race", "-cover", "-coverprofile=", "-run=", "-count=", "-timeout=", "--if-present", "--silent", "--maxfail=", "--disable-warnings", "--release", "--locked", "--offline", "--features=", "--all-features", "--no-default-features", "--package=", "--tests", "-P", "--no-daemon", "-D"},
						DeniedPrefix:  []string{"-exec", "-toolexec", "-mod=mod", "-modfile", "-buildmode=plugin", "-f", "--file", "--require", "--import", "--project-cache-dir"},
						DenyCharacters: []string{
							";", "|", "&", "`", "$(", ">", "<", "\n", "\r",
						},
					},
				},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "repo.test"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "repo.run_tests",
			Description:      "Execute repository test suite with repo-aware defaults.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"extra_args":{"type":"array","items":{"type":"string"}}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain a supported project type"},
			Postconditions:   []string{"test reports can be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				ArgFields: []domain.PolicyArgField{
					{
						Field:         "extra_args",
						Multi:         true,
						MaxItems:      8,
						MaxLength:     64,
						AllowedPrefix: []string{"-v", "-q", "-race", "-cover", "-coverprofile=", "-run=", "-count=", "-timeout=", "--if-present", "--silent", "--maxfail=", "--disable-warnings", "--release", "--locked", "--offline", "--features=", "--all-features", "--no-default-features", "--package=", "--tests", "-P", "--no-daemon", "-D"},
						DeniedPrefix:  []string{"-exec", "-toolexec", "-mod=mod", "-modfile", "-buildmode=plugin", "-f", "--file", "--require", "--import", "--project-cache-dir"},
						DenyCharacters: []string{
							";", "|", "&", "`", "$(", ">", "<", "\n", "\r",
						},
					},
				},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "repo.run_tests"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "repo.coverage_report",
			Description:      "Run repository tests and return a normalized coverage report.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"coverage_supported":{"type":"boolean"},"coverage_percent":{"type":"number"},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 240, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain a supported project type"},
			Postconditions:   []string{"coverage artifacts may be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "repo.coverage_report"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "repo.static_analysis",
			Description:      "Run project-aware static analysis and lint checks.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"diagnostics":{"type":"array","items":{"type":"string"}},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain a supported project type"},
			Postconditions:   []string{"analysis diagnostics may be generated"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "repo.static_analysis"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "repo.package",
			Description:      "Package repository output into deployable artifacts.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"artifact_path":{"type":"string"},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain a supported project type"},
			Postconditions:   []string{"packaged artifacts may be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "repo.package"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"."}`),
			},
		},
		{
			Name:             "security.scan_secrets",
			Description:      "Scan workspace files for likely hardcoded secrets.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"max_results":{"type":"integer","minimum":1,"maximum":2000}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"findings_count":{"type":"integer"},"findings":{"type":"array","items":{"type":"object","properties":{"path":{"type":"string"},"line":{"type":"integer"},"snippet":{"type":"string"}}}},"truncated":{"type":"boolean"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 90, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"path must be inside allowed_paths"},
			Postconditions:   []string{"no repository mutation"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "security.scan_secrets"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","max_results":100}`),
			},
		},
		{
			Name:             "ci.run_pipeline",
			Description:      "Execute a deterministic CI-like sequence: validate, build, test, and optional analysis/coverage.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"include_static_analysis":{"type":"boolean"},"include_coverage":{"type":"boolean"},"fail_fast":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"steps":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"status":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"}}}},"exit_code":{"type":"integer"},"failed_step":{"type":"string"},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 600, MaxRetries: 0, OutputLimitKB: 4096},
			Preconditions:    []string{"workspace must contain a supported project type"},
			Postconditions:   []string{"build/test artifacts may be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "ci.run_pipeline"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./...","include_static_analysis":true,"include_coverage":true,"fail_fast":true}`),
			},
		},
		{
			Name:             "go.mod.tidy",
			Description:      "Run go mod tidy to validate and normalize module dependencies.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"check":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace must contain go.mod"},
			Postconditions:   []string{"go.mod/go.sum may be updated"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "go.mod.tidy"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"check":true}`),
			},
		},
		{
			Name:             "go.generate",
			Description:      "Run go generate for a package target.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace must contain go.mod"},
			Postconditions:   []string{"generated files may be updated"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "go.generate"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "go.build",
			Description:      "Compile Go package with restricted build flags and optional output binary name.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"ldflags":{"type":"string"},"output_name":{"type":"string"},"race":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain go.mod"},
			Postconditions:   []string{"build artifacts may be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "go.build"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./cmd/app","output_name":"app","ldflags":"-s -w","race":false}`),
			},
		},
		{
			Name:             "go.test",
			Description:      "Run Go tests with optional coverage and run-pattern filter.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"package":{"type":"string"},"coverage":{"type":"boolean"},"run_pattern":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain go.mod"},
			Postconditions:   []string{"test reports can be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "go.test"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"package":"./...","coverage":true}`),
			},
		},
		{
			Name:             "rust.build",
			Description:      "Compile Rust project/package with cargo build.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"release":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain Cargo.toml"},
			Postconditions:   []string{"target artifacts may be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "rust.build"},
		},
		{
			Name:             "rust.test",
			Description:      "Run Rust tests using cargo test.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain Cargo.toml"},
			Postconditions:   []string{"test output may be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "rust.test"},
		},
		{
			Name:             "rust.clippy",
			Description:      "Run clippy lints for Rust project.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"deny_warnings":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain Cargo.toml"},
			Postconditions:   []string{"lint diagnostics may be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "rust.clippy"},
		},
		{
			Name:             "rust.format",
			Description:      "Run rustfmt in check or write mode.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"check":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace must contain Cargo.toml"},
			Postconditions:   []string{"formatting may be updated"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "rust.format"},
		},
		{
			Name:             "node.install",
			Description:      "Install Node dependencies using npm ci/install.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"use_ci":{"type":"boolean"},"ignore_scripts":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain package.json"},
			Postconditions:   []string{"node_modules may be updated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "node.install"},
		},
		{
			Name:             "node.build",
			Description:      "Run Node/TypeScript build script with npm.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain package.json"},
			Postconditions:   []string{"build artifacts may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "target", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "node.build"},
		},
		{
			Name:             "node.test",
			Description:      "Run Node test script with npm.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain package.json"},
			Postconditions:   []string{"test output may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "target", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "node.test"},
		},
		{
			Name:             "node.lint",
			Description:      "Run Node lint script with npm.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 240, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain package.json"},
			Postconditions:   []string{"lint diagnostics may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "target", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "node.lint"},
		},
		{
			Name:             "node.typecheck",
			Description:      "Run TypeScript typecheck script with npm.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 240, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain package.json"},
			Postconditions:   []string{"typecheck diagnostics may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "target", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "node.typecheck"},
		},
		{
			Name:             "python.install_deps",
			Description:      "Install Python dependencies in an isolated venv.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"use_venv":{"type":"boolean"},"requirements_file":{"type":"string"},"constraints_file":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain Python dependency manifest"},
			Postconditions:   []string{"venv and site-packages may be updated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{
					{Field: "requirements_file", WorkspaceRelative: true},
					{Field: "constraints_file", WorkspaceRelative: true},
				},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "python.install_deps"},
		},
		{
			Name:             "python.validate",
			Description:      "Validate Python syntax/bytecode compilation.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace must contain Python sources"},
			Postconditions:   []string{"no repository mutation"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "target", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "python.validate"},
		},
		{
			Name:             "python.test",
			Description:      "Run Python tests with constrained pytest options.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"run_pattern":{"type":"string"},"max_fail":{"type":"integer","minimum":1,"maximum":20}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain pytest-compatible tests"},
			Postconditions:   []string{"test output may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "target", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "python.test"},
		},
		{
			Name:             "c.build",
			Description:      "Compile C source files with constrained compiler options.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"source":{"type":"string"},"output_name":{"type":"string"},"standard":{"type":"string","enum":["c89","c99","c11","c17","c23"]}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace must contain C source files"},
			Postconditions:   []string{"compiled binary may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "source", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "c.build"},
		},
		{
			Name:             "c.test",
			Description:      "Compile and optionally run C test source files.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"source":{"type":"string"},"output_name":{"type":"string"},"standard":{"type":"string","enum":["c89","c99","c11","c17","c23"]},"run":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain C test source files"},
			Postconditions:   []string{"test binary/output may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "source", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "c.test"},
		},
	}
}

func mustRawJSON(input string) json.RawMessage {
	return json.RawMessage(input)
}
