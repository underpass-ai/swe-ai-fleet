package tools

import (
	"encoding/json"

	"github.com/underpass-ai/swe-ai-fleet/services/workspace/internal/domain"
)

func DefaultCapabilities() []domain.Capability {
	return []domain.Capability{
		{
			Name:             "fs.list",
			Description:      "List files/directories under the session workspace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"recursive":{"type":"boolean"},"max_entries":{"type":"integer","minimum":1,"maximum":1000}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"entries":{"type":"array"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 15, MaxRetries: 0, OutputLimitKB: 256},
			Preconditions:    []string{"path must be inside allowed_paths"},
			Postconditions:   []string{"no file system mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "fs.list"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","recursive":false}`),
			},
		},
		{
			Name:             "fs.read_file",
			Description:      "Read a text or binary file from workspace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576}},"required":["path"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"content":{"type":"string"},"encoding":{"type":"string"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"path must be inside allowed_paths and point to a regular file"},
			Postconditions:   []string{"no file system mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "fs.read_file"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":"README.md"}`),
			},
		},
		{
			Name:             "fs.write_file",
			Description:      "Write a file in workspace using UTF-8 or base64 payload.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"content":{"type":"string"},"encoding":{"type":"string","enum":["utf8","base64"]},"create_parents":{"type":"boolean"}},"required":["path","content"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"bytes_written":{"type":"integer"},"sha256":{"type":"string"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 256},
			Preconditions:    []string{"path must be inside allowed_paths"},
			Postconditions:   []string{"target file updated"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "fs.write_file"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":"notes/todo.txt","content":"hello","create_parents":true}`),
			},
		},
		{
			Name:             "fs.patch",
			Description:      "Apply a unified diff patch to files in the workspace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"unified_diff":{"type":"string"},"strategy":{"type":"string","enum":["apply","reject_on_conflict"]}},"required":["unified_diff"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"applied":{"type":"boolean"},"strategy":{"type":"string"},"changed_paths":{"type":"array","items":{"type":"string"}},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 45, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"patch paths must be inside allowed_paths"},
			Postconditions:   []string{"workspace files may change"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "fs.patch"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"unified_diff":"diff --git a/file b/file\n...","strategy":"reject_on_conflict"}`),
			},
		},
		{
			Name:             "fs.search",
			Description:      "Search file contents using regex pattern.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"pattern":{"type":"string"},"max_results":{"type":"integer","minimum":1,"maximum":2000}},"required":["pattern"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"matches":{"type":"array"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 512},
			Preconditions:    []string{"path must be inside allowed_paths"},
			Postconditions:   []string{"no file system mutation"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "fs.search"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","pattern":"TODO","max_results":50}`),
			},
		},
		{
			Name:             "conn.list_profiles",
			Description:      "List governable external connection profiles visible to the session principal.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profiles":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string"},"kind":{"type":"string"},"description":{"type":"string"},"read_only":{"type":"boolean"},"scopes":{"type":"object"}}}},"count":{"type":"integer"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 10, MaxRetries: 0, OutputLimitKB: 256},
			Preconditions:    []string{"session metadata may restrict allowed profiles"},
			Postconditions:   []string{"no state mutation"},
			CostHint:         "low",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "conn.list_profiles"},
			Examples: []json.RawMessage{
				mustRawJSON(`{}`),
			},
		},
		{
			Name:             "conn.describe_profile",
			Description:      "Describe a specific connection profile (without exposing credentials).",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"}},"required":["profile_id"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile":{"type":"object","properties":{"id":{"type":"string"},"kind":{"type":"string"},"description":{"type":"string"},"read_only":{"type":"boolean"},"scopes":{"type":"object"}}}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 10, MaxRetries: 0, OutputLimitKB: 128},
			Preconditions:    []string{"profile_id must refer to a visible profile"},
			Postconditions:   []string{"no state mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "conn.describe_profile"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.redis"}`),
			},
		},
		{
			Name:             "nats.request",
			Description:      "Send NATS request/reply call with profile-governed subject limits.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"subject":{"type":"string"},"payload":{"type":"string"},"payload_encoding":{"type":"string","enum":["utf8","base64"]},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576}},"required":["profile_id","subject"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"subject":{"type":"string"},"response_base64":{"type":"string"},"response_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"profile_id and subject must be allowlisted"},
			Postconditions:   []string{"request-reply interaction completed"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				SubjectFields: []domain.PolicySubjectField{{Field: "subject"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "nats.request"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.nats","subject":"sandbox.echo","payload":"hello","payload_encoding":"utf8","timeout_ms":2000}`),
			},
		},
		{
			Name:             "nats.subscribe_pull",
			Description:      "Pull messages from NATS subject with deterministic limits.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"subject":{"type":"string"},"max_messages":{"type":"integer","minimum":1,"maximum":100},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","subject"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"subject":{"type":"string"},"messages":{"type":"array","items":{"type":"object","properties":{"subject":{"type":"string"},"data_base64":{"type":"string"},"size_bytes":{"type":"integer"},"data_trimmed":{"type":"boolean"}}}},"message_count":{"type":"integer"},"total_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"profile_id and subject must be allowlisted"},
			Postconditions:   []string{"bounded message batch returned"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				SubjectFields: []domain.PolicySubjectField{{Field: "subject"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "nats.subscribe_pull"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.nats","subject":"sandbox.events","max_messages":20,"timeout_ms":2000}`),
			},
		},
		{
			Name:             "kafka.consume",
			Description:      "Consume Kafka messages from an allowlisted topic with bounded output.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"topic":{"type":"string"},"partition":{"type":"integer","minimum":0},"offset":{"type":"string","enum":["earliest","latest"]},"max_messages":{"type":"integer","minimum":1,"maximum":200},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","topic"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"topic":{"type":"string"},"messages":{"type":"array","items":{"type":"object","properties":{"partition":{"type":"integer"},"offset":{"type":"integer"},"timestamp_unix":{"type":"integer"},"key_base64":{"type":"string"},"value_base64":{"type":"string"},"size_bytes":{"type":"integer"},"key_trimmed":{"type":"boolean"},"value_trimmed":{"type":"boolean"}}}},"message_count":{"type":"integer"},"total_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"profile_id and topic must be allowlisted"},
			Postconditions:   []string{"bounded message batch returned"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				TopicFields:   []domain.PolicyTopicField{{Field: "topic"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "kafka.consume"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.kafka","topic":"sandbox.events","partition":0,"offset":"latest","max_messages":20,"timeout_ms":2000}`),
			},
		},
		{
			Name:             "kafka.topic_metadata",
			Description:      "Describe Kafka topic metadata for an allowlisted topic.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"topic":{"type":"string"}},"required":["profile_id","topic"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"topic":{"type":"string"},"partition_count":{"type":"integer"},"partitions":{"type":"array","items":{"type":"object","properties":{"partition":{"type":"integer"},"leader_host":{"type":"string"},"leader_port":{"type":"integer"},"replica_ids":{"type":"array","items":{"type":"integer"}},"isr_ids":{"type":"array","items":{"type":"integer"}},"replica_count":{"type":"integer"},"isr_count":{"type":"integer"}}}}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 512},
			Preconditions:    []string{"profile_id and topic must be allowlisted"},
			Postconditions:   []string{"no state mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				TopicFields:   []domain.PolicyTopicField{{Field: "topic"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "kafka.topic_metadata"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.kafka","topic":"sandbox.events"}`),
			},
		},
		{
			Name:             "rabbit.consume",
			Description:      "Consume RabbitMQ messages from an allowlisted queue with bounded output.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"queue":{"type":"string"},"max_messages":{"type":"integer","minimum":1,"maximum":200},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","queue"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"queue":{"type":"string"},"messages":{"type":"array","items":{"type":"object","properties":{"exchange":{"type":"string"},"routing_key":{"type":"string"},"redelivered":{"type":"boolean"},"timestamp_unix":{"type":"integer"},"body_base64":{"type":"string"},"size_bytes":{"type":"integer"},"body_trimmed":{"type":"boolean"}}}},"message_count":{"type":"integer"},"total_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"profile_id and queue must be allowlisted"},
			Postconditions:   []string{"bounded message batch returned"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				QueueFields:   []domain.PolicyQueueField{{Field: "queue"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "rabbit.consume"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.rabbit","queue":"sandbox.jobs","max_messages":20,"timeout_ms":2000}`),
			},
		},
		{
			Name:             "rabbit.queue_info",
			Description:      "Inspect RabbitMQ queue metrics for an allowlisted queue.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"queue":{"type":"string"},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","queue"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"queue":{"type":"string"},"messages":{"type":"integer"},"consumers":{"type":"integer"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 256},
			Preconditions:    []string{"profile_id and queue must be allowlisted"},
			Postconditions:   []string{"no state mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				QueueFields:   []domain.PolicyQueueField{{Field: "queue"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "rabbit.queue_info"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.rabbit","queue":"sandbox.jobs"}`),
			},
		},
		{
			Name:             "redis.get",
			Description:      "Read a single Redis key from an allowlisted key prefix.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"key":{"type":"string"},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","key"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"key":{"type":"string"},"found":{"type":"boolean"},"value_base64":{"type":"string"},"value_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 15, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"profile_id and key prefix must be allowlisted"},
			Postconditions:   []string{"no state mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields:   []domain.PolicyProfileField{{Field: "profile_id"}},
				KeyPrefixFields: []domain.PolicyKeyPrefixField{{Field: "key"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "redis.get"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.redis","key":"sandbox:todo:1","max_bytes":4096}`),
			},
		},
		{
			Name:             "redis.mget",
			Description:      "Read multiple Redis keys from allowlisted key prefixes.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"keys":{"type":"array","items":{"type":"string"},"minItems":1,"maxItems":200},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","keys"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"entries":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"found":{"type":"boolean"},"value_base64":{"type":"string"},"value_bytes":{"type":"integer"},"value_trimmed":{"type":"boolean"}}}},"key_count":{"type":"integer"},"found_count":{"type":"integer"},"total_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"profile_id and all key prefixes must be allowlisted"},
			Postconditions:   []string{"no state mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields:   []domain.PolicyProfileField{{Field: "profile_id"}},
				KeyPrefixFields: []domain.PolicyKeyPrefixField{{Field: "keys", Multi: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "redis.mget"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.redis","keys":["sandbox:todo:1","sandbox:todo:2"]}`),
			},
		},
		{
			Name:             "redis.scan",
			Description:      "Scan Redis keys under an allowlisted prefix with deterministic bounds.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"prefix":{"type":"string"},"cursor":{"type":"integer","minimum":0},"max_keys":{"type":"integer","minimum":1,"maximum":1000},"count_hint":{"type":"integer","minimum":1,"maximum":1000},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","prefix"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"prefix":{"type":"string"},"keys":{"type":"array","items":{"type":"string"}},"count":{"type":"integer"},"next_cursor":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"profile_id and prefix must be allowlisted"},
			Postconditions:   []string{"no state mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields:   []domain.PolicyProfileField{{Field: "profile_id"}},
				KeyPrefixFields: []domain.PolicyKeyPrefixField{{Field: "prefix"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "redis.scan"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.redis","prefix":"sandbox:todo:","max_keys":100}`),
			},
		},
		{
			Name:             "redis.ttl",
			Description:      "Get TTL metadata for a Redis key in an allowlisted prefix.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"key":{"type":"string"},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","key"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"key":{"type":"string"},"exists":{"type":"boolean"},"status":{"type":"string"},"ttl_seconds":{"type":"integer"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 15, MaxRetries: 0, OutputLimitKB: 128},
			Preconditions:    []string{"profile_id and key prefix must be allowlisted"},
			Postconditions:   []string{"no state mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields:   []domain.PolicyProfileField{{Field: "profile_id"}},
				KeyPrefixFields: []domain.PolicyKeyPrefixField{{Field: "key"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "redis.ttl"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.redis","key":"sandbox:todo:1"}`),
			},
		},
		{
			Name:             "redis.exists",
			Description:      "Check existence for Redis keys in allowlisted prefixes.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"keys":{"type":"array","items":{"type":"string"},"minItems":1,"maxItems":200},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","keys"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"keys_checked":{"type":"integer"},"exists_count":{"type":"integer"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 15, MaxRetries: 0, OutputLimitKB: 128},
			Preconditions:    []string{"profile_id and key prefixes must be allowlisted"},
			Postconditions:   []string{"no state mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields:   []domain.PolicyProfileField{{Field: "profile_id"}},
				KeyPrefixFields: []domain.PolicyKeyPrefixField{{Field: "keys", Multi: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "redis.exists"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.redis","keys":["sandbox:todo:1","sandbox:todo:2"]}`),
			},
		},
		{
			Name:             "redis.set",
			Description:      "Set a Redis key with mandatory TTL in an allowlisted prefix.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"key":{"type":"string"},"value":{"type":"string"},"value_encoding":{"type":"string","enum":["utf8","base64"]},"ttl_seconds":{"type":"integer","minimum":1,"maximum":604800},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","key","value","ttl_seconds"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"key":{"type":"string"},"ttl_seconds":{"type":"integer"},"value_bytes":{"type":"integer"},"value_format":{"type":"string"},"written":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 15, MaxRetries: 0, OutputLimitKB: 128},
			Preconditions:    []string{"profile_id and key prefix must be allowlisted", "ttl_seconds is required", "explicit approval required"},
			Postconditions:   []string{"key value updated with ttl"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields:   []domain.PolicyProfileField{{Field: "profile_id"}},
				KeyPrefixFields: []domain.PolicyKeyPrefixField{{Field: "key"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "redis.set"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.redis","key":"sandbox:todo:1","value":"{\"title\":\"demo\"}","ttl_seconds":3600}`),
			},
		},
		{
			Name:             "redis.del",
			Description:      "Delete Redis keys from allowlisted prefixes.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"keys":{"type":"array","items":{"type":"string"},"minItems":1,"maxItems":200},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","keys"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"keys_requested":{"type":"integer"},"deleted":{"type":"integer"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsIrreversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 15, MaxRetries: 0, OutputLimitKB: 128},
			Preconditions:    []string{"profile_id and key prefixes must be allowlisted", "explicit approval required"},
			Postconditions:   []string{"keys may be deleted"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields:   []domain.PolicyProfileField{{Field: "profile_id"}},
				KeyPrefixFields: []domain.PolicyKeyPrefixField{{Field: "keys", Multi: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "redis.del"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.redis","keys":["sandbox:todo:1","sandbox:todo:2"]}`),
			},
		},
		{
			Name:             "mongo.find",
			Description:      "Find MongoDB documents from an allowlisted database with a hard result limit.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"database":{"type":"string"},"collection":{"type":"string"},"filter":{"type":"object"},"projection":{"type":"object"},"sort":{"type":"object"},"limit":{"type":"integer","minimum":1,"maximum":200},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","database","collection"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"database":{"type":"string"},"collection":{"type":"string"},"documents":{"type":"array","items":{"type":"object"}},"document_count":{"type":"integer"},"effective_limit":{"type":"integer"},"total_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"profile_id and database must be allowlisted"},
			Postconditions:   []string{"no state mutation"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "mongo.find"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.mongo","database":"sandbox","collection":"todos","filter":{"status":"open"},"limit":50}`),
			},
		},
		{
			Name:             "mongo.aggregate",
			Description:      "Run MongoDB aggregation with a server-side hard result limit.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"database":{"type":"string"},"collection":{"type":"string"},"pipeline":{"type":"array","items":{"type":"object"}},"limit":{"type":"integer","minimum":1,"maximum":200},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","database","collection"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"database":{"type":"string"},"collection":{"type":"string"},"documents":{"type":"array","items":{"type":"object"}},"document_count":{"type":"integer"},"effective_limit":{"type":"integer"},"total_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"profile_id and database must be allowlisted"},
			Postconditions:   []string{"no state mutation"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "mongo.aggregate"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.mongo","database":"sandbox","collection":"todos","pipeline":[{"$match":{"status":"done"}}],"limit":50}`),
			},
		},
		{
			Name:             "git.status",
			Description:      "Run git status in the workspace repository.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"short":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"status":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 1, OutputLimitKB: 256},
			Preconditions:    []string{"workspace must contain a git repository"},
			Postconditions:   []string{"no repository mutation"},
			CostHint:         "low",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "git.status"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"short":true}`),
			},
		},
		{
			Name:             "git.diff",
			Description:      "Return unified diff from git workspace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"staged":{"type":"boolean"},"paths":{"type":"array","items":{"type":"string"}},"base":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"diff":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 1, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace must contain a git repository"},
			Postconditions:   []string{"no repository mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "paths", Multi: true, WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "git.diff"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"staged":false}`),
			},
		},
		{
			Name:             "git.apply_patch",
			Description:      "Apply a unified diff patch using git apply.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"patch":{"type":"string"},"check":{"type":"boolean"}},"required":["patch"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"applied":{"type":"boolean"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 45, MaxRetries: 0, OutputLimitKB: 512},
			Preconditions:    []string{"workspace must contain a git repository"},
			Postconditions:   []string{"working tree may change"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "git.apply_patch"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"patch":"diff --git ...","check":true}`),
			},
		},
		{
			Name:             "repo.detect_project_type",
			Description:      "Detect repository project type for build/test orchestration.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"flavor":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 15, MaxRetries: 0, OutputLimitKB: 64},
			Preconditions:    []string{"workspace must be initialized"},
			Postconditions:   []string{"no repository mutation"},
			CostHint:         "low",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "repo.detect_project_type"},
			Examples: []json.RawMessage{
				mustRawJSON(`{}`),
			},
		},
		{
			Name:             "repo.detect_toolchain",
			Description:      "Detect language toolchain metadata for orchestration.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"language":{"type":"string"},"build_system":{"type":"string"},"test_framework":{"type":"string"},"containerizable":{"type":"boolean"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 64},
			Preconditions:    []string{"workspace must be initialized"},
			Postconditions:   []string{"no repository mutation"},
			CostHint:         "low",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "repo.detect_toolchain"},
			Examples: []json.RawMessage{
				mustRawJSON(`{}`),
			},
		},
		{
			Name:             "repo.validate",
			Description:      "Run toolchain-aware repository validation (syntax/compile checks).",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"language":{"type":"string"},"build_system":{"type":"string"},"test_framework":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"diagnostics":{"type":"array","items":{"type":"string"}},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain a supported project type"},
			Postconditions:   []string{"validation output can be generated"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "repo.validate"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "repo.build",
			Description:      "Execute project build command with repository-aware defaults.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"extra_args":{"type":"array","items":{"type":"string"}}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 240, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain a supported project type"},
			Postconditions:   []string{"build artifacts may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				ArgFields: []domain.PolicyArgField{
					{
						Field:         "extra_args",
						Multi:         true,
						MaxItems:      8,
						MaxLength:     64,
						AllowedPrefix: []string{"-v", "-q", "-race", "-trimpath", "-tags=", "-cover", "-coverprofile=", "-run=", "-count=", "-timeout=", "--if-present", "--silent", "--maxfail=", "--disable-warnings", "--release", "--locked", "--offline", "--features=", "--all-features", "--no-default-features", "--package=", "--tests", "-P", "--no-daemon", "-D"},
						DeniedPrefix:  []string{"-exec", "-toolexec", "-mod=mod", "-modfile", "-buildmode=plugin", "-f", "--file", "--require", "--import", "--project-cache-dir"},
						DenyCharacters: []string{
							";", "|", "&", "`", "$(", ">", "<", "\n", "\r",
						},
					},
				},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "repo.build"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "repo.test",
			Description:      "Execute repository test suite (preferred alias of repo.run_tests).",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"extra_args":{"type":"array","items":{"type":"string"}}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain a supported project type"},
			Postconditions:   []string{"test reports can be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				ArgFields: []domain.PolicyArgField{
					{
						Field:         "extra_args",
						Multi:         true,
						MaxItems:      8,
						MaxLength:     64,
						AllowedPrefix: []string{"-v", "-q", "-race", "-cover", "-coverprofile=", "-run=", "-count=", "-timeout=", "--if-present", "--silent", "--maxfail=", "--disable-warnings", "--release", "--locked", "--offline", "--features=", "--all-features", "--no-default-features", "--package=", "--tests", "-P", "--no-daemon", "-D"},
						DeniedPrefix:  []string{"-exec", "-toolexec", "-mod=mod", "-modfile", "-buildmode=plugin", "-f", "--file", "--require", "--import", "--project-cache-dir"},
						DenyCharacters: []string{
							";", "|", "&", "`", "$(", ">", "<", "\n", "\r",
						},
					},
				},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "repo.test"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "repo.run_tests",
			Description:      "Execute repository test suite with repo-aware defaults.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"extra_args":{"type":"array","items":{"type":"string"}}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain a supported project type"},
			Postconditions:   []string{"test reports can be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				ArgFields: []domain.PolicyArgField{
					{
						Field:         "extra_args",
						Multi:         true,
						MaxItems:      8,
						MaxLength:     64,
						AllowedPrefix: []string{"-v", "-q", "-race", "-cover", "-coverprofile=", "-run=", "-count=", "-timeout=", "--if-present", "--silent", "--maxfail=", "--disable-warnings", "--release", "--locked", "--offline", "--features=", "--all-features", "--no-default-features", "--package=", "--tests", "-P", "--no-daemon", "-D"},
						DeniedPrefix:  []string{"-exec", "-toolexec", "-mod=mod", "-modfile", "-buildmode=plugin", "-f", "--file", "--require", "--import", "--project-cache-dir"},
						DenyCharacters: []string{
							";", "|", "&", "`", "$(", ">", "<", "\n", "\r",
						},
					},
				},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "repo.run_tests"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "repo.test_failures_summary",
			Description:      "Summarize failed tests from provided test output or by executing repository tests.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"output":{"type":"string"},"target":{"type":"string"},"extra_args":{"type":"array","items":{"type":"string"}},"max_failures":{"type":"integer","minimum":1,"maximum":200},"max_diagnostics":{"type":"integer","minimum":1,"maximum":200}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"source":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"failed_count":{"type":"integer"},"failed_tests":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"kind":{"type":"string"},"line":{"type":"string"}}}},"diagnostics":{"type":"array","items":{"type":"string"}},"output_excerpt":{"type":"string"},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace must contain a supported project type when output is omitted"},
			Postconditions:   []string{"test failure summary artifact may be generated"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ArgFields: []domain.PolicyArgField{
					{
						Field:         "extra_args",
						Multi:         true,
						MaxItems:      8,
						MaxLength:     64,
						AllowedPrefix: []string{"-v", "-q", "-race", "-cover", "-coverprofile=", "-run=", "-count=", "-timeout=", "--if-present", "--silent", "--maxfail=", "--disable-warnings", "--release", "--locked", "--offline", "--features=", "--all-features", "--no-default-features", "--package=", "--tests", "-P", "--no-daemon", "-D"},
						DeniedPrefix:  []string{"-exec", "-toolexec", "-mod=mod", "-modfile", "-buildmode=plugin", "-f", "--file", "--require", "--import", "--project-cache-dir"},
						DenyCharacters: []string{
							";", "|", "&", "`", "$(", ">", "<", "\n", "\r",
						},
					},
				},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "repo.test_failures_summary"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"output":"--- FAIL: TestCreateTodo (0.00s)\nFAIL\tgithub.com/acme/todo\t0.01s"}`),
				mustRawJSON(`{"target":"./...","max_failures":20}`),
			},
		},
		{
			Name:             "repo.stacktrace_summary",
			Description:      "Summarize stacktraces from provided output or by executing repository tests.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"output":{"type":"string"},"target":{"type":"string"},"extra_args":{"type":"array","items":{"type":"string"}},"max_traces":{"type":"integer","minimum":1,"maximum":50},"max_frames":{"type":"integer","minimum":1,"maximum":80}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"source":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"trace_count":{"type":"integer"},"stacktraces":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"message":{"type":"string"},"frames":{"type":"array","items":{"type":"string"}},"frame_count":{"type":"integer"}}}},"diagnostics":{"type":"array","items":{"type":"string"}},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace must contain a supported project type when output is omitted"},
			Postconditions:   []string{"stacktrace summary artifact may be generated"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ArgFields: []domain.PolicyArgField{
					{
						Field:         "extra_args",
						Multi:         true,
						MaxItems:      8,
						MaxLength:     64,
						AllowedPrefix: []string{"-v", "-q", "-race", "-cover", "-coverprofile=", "-run=", "-count=", "-timeout=", "--if-present", "--silent", "--maxfail=", "--disable-warnings", "--release", "--locked", "--offline", "--features=", "--all-features", "--no-default-features", "--package=", "--tests", "-P", "--no-daemon", "-D"},
						DeniedPrefix:  []string{"-exec", "-toolexec", "-mod=mod", "-modfile", "-buildmode=plugin", "-f", "--file", "--require", "--import", "--project-cache-dir"},
						DenyCharacters: []string{
							";", "|", "&", "`", "$(", ">", "<", "\n", "\r",
						},
					},
				},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "repo.stacktrace_summary"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"output":"panic: runtime error\nmain.main()\n/workspace/repo/main.go:11 +0x29"}`),
				mustRawJSON(`{"target":"./...","max_traces":5,"max_frames":12}`),
			},
		},
		{
			Name:             "repo.changed_files",
			Description:      "Return deterministic changed file metadata from git status/diff or provided status output.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"base_ref":{"type":"string"},"path":{"type":"string"},"max_files":{"type":"integer","minimum":1,"maximum":2000},"include_untracked":{"type":"boolean"},"output":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"source":{"type":"string"},"mode":{"type":"string"},"base_ref":{"type":"string"},"path":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"changed_count":{"type":"integer"},"changed_files":{"type":"array","items":{"type":"object","properties":{"path":{"type":"string"},"status":{"type":"string"},"index_status":{"type":"string"},"worktree_status":{"type":"string"},"staged":{"type":"boolean"},"unstaged":{"type":"boolean"},"untracked":{"type":"boolean"},"deleted":{"type":"boolean"},"renamed_from":{"type":"string"}}}},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 90, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace should be a git repository when output is omitted"},
			Postconditions:   []string{"changed files summary artifact may be generated"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{
					{Field: "path", WorkspaceRelative: true},
				},
				ArgFields: []domain.PolicyArgField{
					{
						Field:          "base_ref",
						MaxLength:      120,
						DenyCharacters: []string{";", "|", "&", "`", "$(", ">", "<", "\n", "\r"},
					},
				},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "repo.changed_files"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","max_files":100}`),
				mustRawJSON(`{"base_ref":"origin/main","path":"internal"}`),
			},
		},
		{
			Name:             "repo.symbol_search",
			Description:      "Search symbols with deterministic file/line/column matches in allowed workspace paths.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"symbol":{"type":"string"},"path":{"type":"string"},"max_results":{"type":"integer","minimum":1,"maximum":2000},"case_sensitive":{"type":"boolean"},"whole_word":{"type":"boolean"},"use_regex":{"type":"boolean"}},"required":["symbol"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"symbol":{"type":"string"},"path":{"type":"string"},"case_sensitive":{"type":"boolean"},"whole_word":{"type":"boolean"},"use_regex":{"type":"boolean"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"matches_count":{"type":"integer"},"truncated":{"type":"boolean"},"matches":{"type":"array","items":{"type":"object","properties":{"path":{"type":"string"},"line":{"type":"integer"},"column":{"type":"integer"},"snippet":{"type":"string"}}}},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 120, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"symbol must be non-empty"},
			Postconditions:   []string{"symbol search artifact may be generated"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{
					{Field: "path", WorkspaceRelative: true},
				},
				ArgFields: []domain.PolicyArgField{
					{
						Field:          "symbol",
						MaxLength:      160,
						DenyCharacters: []string{"\x00", "\n", "\r"},
					},
				},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "repo.symbol_search"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"symbol":"CreateTodo","path":"."}`),
				mustRawJSON(`{"symbol":"^Test.*Todo$","use_regex":true,"path":"."}`),
			},
		},
		{
			Name:             "repo.find_references",
			Description:      "Find symbol references with declaration tagging for refactor-safe reasoning.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"symbol":{"type":"string"},"path":{"type":"string"},"max_references":{"type":"integer","minimum":1,"maximum":2000},"max_results":{"type":"integer","minimum":1,"maximum":2000},"case_sensitive":{"type":"boolean"},"include_declarations":{"type":"boolean"}},"required":["symbol"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"symbol":{"type":"string"},"path":{"type":"string"},"case_sensitive":{"type":"boolean"},"include_declarations":{"type":"boolean"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"references_count":{"type":"integer"},"declaration_count":{"type":"integer"},"truncated":{"type":"boolean"},"references":{"type":"array","items":{"type":"object","properties":{"path":{"type":"string"},"line":{"type":"integer"},"column":{"type":"integer"},"snippet":{"type":"string"},"is_declaration":{"type":"boolean"}}}},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 120, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"symbol must be non-empty"},
			Postconditions:   []string{"references summary artifact may be generated"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{
					{Field: "path", WorkspaceRelative: true},
				},
				ArgFields: []domain.PolicyArgField{
					{
						Field:          "symbol",
						MaxLength:      160,
						DenyCharacters: []string{"\x00", "\n", "\r"},
					},
				},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "repo.find_references"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"symbol":"CreateTodo","path":"."}`),
				mustRawJSON(`{"symbol":"Todo","include_declarations":false}`),
			},
		},
		{
			Name:             "repo.coverage_report",
			Description:      "Run repository tests and return a normalized coverage report.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"coverage_supported":{"type":"boolean"},"coverage_percent":{"type":"number"},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 240, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain a supported project type"},
			Postconditions:   []string{"coverage artifacts may be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "repo.coverage_report"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "repo.static_analysis",
			Description:      "Run project-aware static analysis and lint checks.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"diagnostics":{"type":"array","items":{"type":"string"}},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain a supported project type"},
			Postconditions:   []string{"analysis diagnostics may be generated"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "repo.static_analysis"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "repo.package",
			Description:      "Package repository output into deployable artifacts.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"artifact_path":{"type":"string"},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain a supported project type"},
			Postconditions:   []string{"packaged artifacts may be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "repo.package"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"."}`),
			},
		},
		{
			Name:             "image.build",
			Description:      "Build container image from workspace Dockerfile using available builder with deterministic fallback.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"context_path":{"type":"string"},"dockerfile_path":{"type":"string"},"tag":{"type":"string"},"push":{"type":"boolean"},"no_cache":{"type":"boolean"},"max_issues":{"type":"integer","minimum":1,"maximum":2000},"include_recommendations":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"builder":{"type":"string"},"simulated":{"type":"boolean"},"context_path":{"type":"string"},"dockerfile_path":{"type":"string"},"tag":{"type":"string"},"image_ref":{"type":"string"},"registry":{"type":"string"},"repository":{"type":"string"},"digest":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"push_command":{"type":"array","items":{"type":"string"}},"push_requested":{"type":"boolean"},"pushed":{"type":"boolean"},"push_skipped_reason":{"type":"string"},"issues_count":{"type":"integer"},"issues":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string"},"severity":{"type":"string"},"line":{"type":"integer"},"message":{"type":"string"},"snippet":{"type":"string"}}}},"recommendations":{"type":"array","items":{"type":"string"}},"truncated":{"type":"boolean"},"exit_code":{"type":"integer"},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 4096},
			Preconditions:    []string{"context_path and dockerfile_path must be inside allowed_paths"},
			Postconditions:   []string{"image build metadata produced; image push may occur when requested"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{
					{Field: "context_path", WorkspaceRelative: true},
					{Field: "dockerfile_path", WorkspaceRelative: true},
				},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "image.build"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"context_path":".","dockerfile_path":"Dockerfile","tag":"ghcr.io/acme/demo:1.0.0","push":false}`),
			},
		},
		{
			Name:             "image.push",
			Description:      "Push an existing container image reference using available builder with deterministic fallback.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"image_ref":{"type":"string"},"max_retries":{"type":"integer","minimum":0,"maximum":5},"strict":{"type":"boolean"},"max_issues":{"type":"integer","minimum":1,"maximum":2000},"include_recommendations":{"type":"boolean"}},"required":["image_ref"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"builder":{"type":"string"},"simulated":{"type":"boolean"},"image_ref":{"type":"string"},"registry":{"type":"string"},"repository":{"type":"string"},"tag":{"type":"string"},"digest":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"attempts":{"type":"integer"},"max_retries":{"type":"integer"},"pushed":{"type":"boolean"},"push_skipped_reason":{"type":"string"},"issues_count":{"type":"integer"},"issues":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string"},"severity":{"type":"string"},"line":{"type":"integer"},"message":{"type":"string"},"snippet":{"type":"string"}}}},"recommendations":{"type":"array","items":{"type":"string"}},"truncated":{"type":"boolean"},"exit_code":{"type":"integer"},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsIrreversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 4096},
			Preconditions:    []string{"image_ref must be a valid image reference"},
			Postconditions:   []string{"image may be pushed to remote registry"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				RegistryFields: []string{"image_ref"},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "image.push"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"image_ref":"ghcr.io/acme/demo:1.0.0@sha256:abc123","max_retries":1}`),
			},
		},
		{
			Name:             "image.inspect",
			Description:      "Inspect Dockerfile or image reference metadata with deterministic security hints.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"context_path":{"type":"string"},"dockerfile_path":{"type":"string"},"image_ref":{"type":"string"},"include_recommendations":{"type":"boolean"},"max_issues":{"type":"integer","minimum":1,"maximum":2000}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"source_type":{"type":"string"},"context_path":{"type":"string"},"dockerfile_path":{"type":"string"},"image_ref":{"type":"string"},"registry":{"type":"string"},"repository":{"type":"string"},"tag":{"type":"string"},"digest":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"base_images":{"type":"array","items":{"type":"string"}},"stages_count":{"type":"integer"},"exposed_ports":{"type":"array","items":{"type":"string"}},"user":{"type":"string"},"entrypoint":{"type":"string"},"cmd":{"type":"string"},"issues_count":{"type":"integer"},"issues":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string"},"severity":{"type":"string"},"line":{"type":"integer"},"message":{"type":"string"},"snippet":{"type":"string"}}}},"recommendations":{"type":"array","items":{"type":"string"}},"truncated":{"type":"boolean"},"exit_code":{"type":"integer"},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 60, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"context_path and dockerfile_path must be inside allowed_paths"},
			Postconditions:   []string{"no repository mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{
					{Field: "context_path", WorkspaceRelative: true},
					{Field: "dockerfile_path", WorkspaceRelative: true},
				},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "image.inspect"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"context_path":".","dockerfile_path":"Dockerfile","max_issues":100}`),
				mustRawJSON(`{"image_ref":"registry.example.com/app:1.2.3@sha256:abc123","include_recommendations":true}`),
			},
		},
		{
			Name:             "artifact.upload",
			Description:      "Read a workspace file and publish it as invocation artifact payload.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"name":{"type":"string"},"content_type":{"type":"string"},"max_bytes":{"type":"integer","minimum":1024,"maximum":10485760}},"required":["path"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"artifact_name":{"type":"string"},"content_type":{"type":"string"},"size_bytes":{"type":"integer"},"sha256":{"type":"string"},"truncated":{"type":"boolean"},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 45, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"path must be inside allowed_paths"},
			Postconditions:   []string{"artifact payload attached to invocation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "artifact.upload"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".workspace-dist/app","name":"app-linux-amd64","content_type":"application/octet-stream"}`),
			},
		},
		{
			Name:             "artifact.download",
			Description:      "Read artifact-like content from workspace and return encoded payload.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"encoding":{"type":"string","enum":["base64","utf8"]},"max_bytes":{"type":"integer","minimum":1024,"maximum":10485760}},"required":["path"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"encoding":{"type":"string"},"content":{"type":"string"},"content_base64":{"type":"string"},"size_bytes":{"type":"integer"},"sha256":{"type":"string"},"truncated":{"type":"boolean"},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 45, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"path must be inside allowed_paths"},
			Postconditions:   []string{"artifact payload returned in tool output"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "artifact.download"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":"coverage-report.txt","encoding":"utf8"}`),
			},
		},
		{
			Name:             "artifact.list",
			Description:      "List candidate artifact files in workspace path.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"recursive":{"type":"boolean"},"pattern":{"type":"string"},"max_entries":{"type":"integer","minimum":1,"maximum":2000}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"recursive":{"type":"boolean"},"pattern":{"type":"string"},"count":{"type":"integer"},"truncated":{"type":"boolean"},"artifacts":{"type":"array","items":{"type":"object","properties":{"path":{"type":"string"},"size_bytes":{"type":"integer"}}}},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 45, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"path must be inside allowed_paths"},
			Postconditions:   []string{"no workspace mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "artifact.list"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".workspace-dist","recursive":true,"pattern":"*.tar.gz"}`),
			},
		},
		{
			Name:             "k8s.get_pods",
			Description:      "List Kubernetes pods in a namespace using the Kubernetes SDK.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"label_selector":{"type":"string"},"field_selector":{"type":"string"},"max_pods":{"type":"integer","minimum":1,"maximum":500},"include_containers":{"type":"boolean"},"include_labels":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"label_selector":{"type":"string"},"field_selector":{"type":"string"},"source":{"type":"string"},"count":{"type":"integer"},"truncated":{"type":"boolean"},"include_containers":{"type":"boolean"},"include_labels":{"type":"boolean"},"pods":{"type":"array","items":{"type":"object"}},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeCluster,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"principal must have cluster-scope access"},
			Postconditions:   []string{"no cluster mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				NamespaceFields: []string{"namespace"},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "k8s.get_pods"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"namespace":"swe-ai-fleet","label_selector":"app=workspace","max_pods":50}`),
			},
		},
		{
			Name:             "k8s.get_services",
			Description:      "List Kubernetes services in a namespace using the Kubernetes SDK.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"label_selector":{"type":"string"},"field_selector":{"type":"string"},"max_services":{"type":"integer","minimum":1,"maximum":500},"include_labels":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"label_selector":{"type":"string"},"field_selector":{"type":"string"},"source":{"type":"string"},"count":{"type":"integer"},"truncated":{"type":"boolean"},"include_labels":{"type":"boolean"},"services":{"type":"array","items":{"type":"object"}},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeCluster,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"principal must have cluster-scope access"},
			Postconditions:   []string{"no cluster mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				NamespaceFields: []string{"namespace"},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "k8s.get_services"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"namespace":"swe-ai-fleet","max_services":50}`),
			},
		},
		{
			Name:             "k8s.get_deployments",
			Description:      "List Kubernetes deployments in a namespace using the Kubernetes SDK.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"label_selector":{"type":"string"},"field_selector":{"type":"string"},"max_deployments":{"type":"integer","minimum":1,"maximum":500},"include_containers":{"type":"boolean"},"include_labels":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"label_selector":{"type":"string"},"field_selector":{"type":"string"},"source":{"type":"string"},"count":{"type":"integer"},"truncated":{"type":"boolean"},"include_containers":{"type":"boolean"},"include_labels":{"type":"boolean"},"deployments":{"type":"array","items":{"type":"object"}},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeCluster,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"principal must have cluster-scope access"},
			Postconditions:   []string{"no cluster mutation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				NamespaceFields: []string{"namespace"},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "k8s.get_deployments"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"namespace":"swe-ai-fleet","include_containers":true}`),
			},
		},
		{
			Name:             "k8s.get_images",
			Description:      "Aggregate container images used by pods in a namespace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"label_selector":{"type":"string"},"field_selector":{"type":"string"},"max_images":{"type":"integer","minimum":1,"maximum":1000},"include_workloads":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"label_selector":{"type":"string"},"field_selector":{"type":"string"},"source":{"type":"string"},"count":{"type":"integer"},"truncated":{"type":"boolean"},"include_workloads":{"type":"boolean"},"images":{"type":"array","items":{"type":"object"}},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeCluster,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 45, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"principal must have cluster-scope access"},
			Postconditions:   []string{"no cluster mutation"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				NamespaceFields: []string{"namespace"},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "k8s.get_images"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"namespace":"swe-ai-fleet","max_images":200}`),
			},
		},
		{
			Name:             "k8s.get_logs",
			Description:      "Fetch logs from a Kubernetes pod container.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"pod_name":{"type":"string"},"container":{"type":"string"},"tail_lines":{"type":"integer","minimum":1,"maximum":10000},"since_seconds":{"type":"integer","minimum":0,"maximum":604800},"previous":{"type":"boolean"},"max_bytes":{"type":"integer","minimum":1024,"maximum":2097152}},"required":["pod_name"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"pod_name":{"type":"string"},"container":{"type":"string"},"tail_lines":{"type":"integer"},"since_seconds":{"type":"integer"},"previous":{"type":"boolean"},"source":{"type":"string"},"bytes":{"type":"integer"},"line_count":{"type":"integer"},"truncated":{"type":"boolean"},"logs":{"type":"string"},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeCluster,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"principal must have cluster-scope access"},
			Postconditions:   []string{"no cluster mutation"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				NamespaceFields: []string{"namespace"},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "k8s.get_logs"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"namespace":"swe-ai-fleet","pod_name":"workspace-abc123","tail_lines":200}`),
			},
		},
		{
			Name:             "security.scan_dependencies",
			Description:      "Collect dependency inventory for the detected project toolchain.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"max_dependencies":{"type":"integer","minimum":1,"maximum":5000}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"dependencies_count":{"type":"integer"},"dependencies":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"version":{"type":"string"},"ecosystem":{"type":"string"},"license":{"type":"string"}}}},"truncated":{"type":"boolean"},"scanner":{"type":"string"},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain a supported project type", "path must be inside allowed_paths"},
			Postconditions:   []string{"dependency inventory artifact may be generated"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "security.scan_dependencies"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","max_dependencies":500}`),
			},
		},
		{
			Name:             "sbom.generate",
			Description:      "Generate a CycloneDX JSON SBOM from repository dependencies.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"format":{"type":"string","enum":["cyclonedx-json"]},"max_components":{"type":"integer","minimum":1,"maximum":10000}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"format":{"type":"string"},"generator":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"components_count":{"type":"integer"},"components":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"name":{"type":"string"},"version":{"type":"string"},"purl":{"type":"string"}}}},"truncated":{"type":"boolean"},"artifact_name":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 240, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain a supported project type", "path must be inside allowed_paths"},
			Postconditions:   []string{"sbom artifact generated"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "sbom.generate"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","format":"cyclonedx-json","max_components":1000}`),
			},
		},
		{
			Name:             "security.scan_secrets",
			Description:      "Scan workspace files for likely hardcoded secrets.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"max_results":{"type":"integer","minimum":1,"maximum":2000}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"findings_count":{"type":"integer"},"findings":{"type":"array","items":{"type":"object","properties":{"path":{"type":"string"},"line":{"type":"integer"},"snippet":{"type":"string"}}}},"truncated":{"type":"boolean"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 90, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"path must be inside allowed_paths"},
			Postconditions:   []string{"no repository mutation"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "security.scan_secrets"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","max_results":100}`),
			},
		},
		{
			Name:             "security.scan_container",
			Description:      "Scan container image or Dockerfile context for vulnerabilities and misconfigurations.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"image_ref":{"type":"string"},"max_findings":{"type":"integer","minimum":1,"maximum":2000},"severity_threshold":{"type":"string","enum":["low","medium","high","critical"]}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"scanner":{"type":"string"},"target":{"type":"string"},"path":{"type":"string"},"image_ref":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"severity_threshold":{"type":"string"},"findings_count":{"type":"integer"},"findings":{"type":"array","items":{"type":"object","properties":{"kind":{"type":"string"},"id":{"type":"string"},"title":{"type":"string"},"severity":{"type":"string"},"target":{"type":"string"}}}},"severity_counts":{"type":"object"},"truncated":{"type":"boolean"},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 240, MaxRetries: 0, OutputLimitKB: 4096},
			Preconditions:    []string{"path must be inside allowed_paths when provided"},
			Postconditions:   []string{"container scan findings may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "security.scan_container"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","max_findings":200,"severity_threshold":"medium"}`),
				mustRawJSON(`{"image_ref":"registry.example.com/app:1.2.3","severity_threshold":"high"}`),
			},
		},
		{
			Name:             "security.license_check",
			Description:      "Evaluate repository dependency licenses against allow/deny policy.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"max_dependencies":{"type":"integer","minimum":1,"maximum":5000},"allowed_licenses":{"type":"array","items":{"type":"string"}},"denied_licenses":{"type":"array","items":{"type":"string"}},"unknown_policy":{"type":"string","enum":["warn","deny"]}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"license_source_command":{"type":"array","items":{"type":"string"}},"dependencies_checked":{"type":"integer"},"allowed_count":{"type":"integer"},"denied_count":{"type":"integer"},"unknown_count":{"type":"integer"},"allowed_licenses":{"type":"array","items":{"type":"string"}},"denied_licenses":{"type":"array","items":{"type":"string"}},"unknown_policy":{"type":"string"},"status":{"type":"string"},"violations":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"version":{"type":"string"},"ecosystem":{"type":"string"},"license":{"type":"string"},"reason":{"type":"string"}}}},"dependencies":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"version":{"type":"string"},"ecosystem":{"type":"string"},"license":{"type":"string"}}}},"truncated":{"type":"boolean"},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 4096},
			Preconditions:    []string{"workspace must contain a supported project type", "path must be inside allowed_paths"},
			Postconditions:   []string{"license compliance report may be generated"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "security.license_check"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","allowed_licenses":["MIT","Apache-2.0"],"denied_licenses":["GPL-3.0"],"unknown_policy":"warn"}`),
			},
		},
		{
			Name:             "quality.gate",
			Description:      "Evaluate quality metrics against deterministic acceptance thresholds.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"metrics":{"type":"object","properties":{"coverage_percent":{"type":"number"},"diagnostics_count":{"type":"integer"},"vulnerabilities_count":{"type":"integer"},"denied_licenses_count":{"type":"integer"},"failed_tests_count":{"type":"integer"}}},"min_coverage_percent":{"type":"number","minimum":0,"maximum":100},"max_diagnostics":{"type":"integer","minimum":-1,"maximum":100000},"max_vulnerabilities":{"type":"integer","minimum":-1,"maximum":100000},"max_denied_licenses":{"type":"integer","minimum":-1,"maximum":100000},"max_failed_tests":{"type":"integer","minimum":-1,"maximum":100000}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"status":{"type":"string"},"passed":{"type":"boolean"},"failed_rules_count":{"type":"integer"},"rules":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"operator":{"type":"string"},"expected":{"type":"number"},"actual":{"type":"number"},"passed":{"type":"boolean"},"message":{"type":"string"}}}},"metrics":{"type":"object"},"thresholds":{"type":"object"},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 256},
			Preconditions:    []string{"quality metrics should be provided for meaningful evaluation"},
			Postconditions:   []string{"quality gate report may be generated"},
			CostHint:         "low",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "quality.gate"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"metrics":{"coverage_percent":82.5,"diagnostics_count":0,"failed_tests_count":0},"min_coverage_percent":80,"max_diagnostics":0,"max_failed_tests":0}`),
			},
		},
		{
			Name:             "ci.run_pipeline",
			Description:      "Execute a deterministic CI-like sequence: validate, build, test, and optional analysis/coverage.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"include_static_analysis":{"type":"boolean"},"include_coverage":{"type":"boolean"},"include_quality_gate":{"type":"boolean"},"fail_fast":{"type":"boolean"},"quality_gate":{"type":"object","properties":{"min_coverage_percent":{"type":"number","minimum":0,"maximum":100},"max_diagnostics":{"type":"integer","minimum":-1,"maximum":100000},"max_vulnerabilities":{"type":"integer","minimum":-1,"maximum":100000},"max_denied_licenses":{"type":"integer","minimum":-1,"maximum":100000},"max_failed_tests":{"type":"integer","minimum":-1,"maximum":100000}}}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"steps":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"status":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"}}}},"quality_metrics":{"type":"object"},"quality_gate":{"type":"object"},"exit_code":{"type":"integer"},"failed_step":{"type":"string"},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 600, MaxRetries: 0, OutputLimitKB: 4096},
			Preconditions:    []string{"workspace must contain a supported project type"},
			Postconditions:   []string{"build/test artifacts may be generated", "quality gate report may be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "ci.run_pipeline"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./...","include_static_analysis":true,"include_coverage":true,"include_quality_gate":true,"quality_gate":{"max_failed_tests":0,"max_diagnostics":0},"fail_fast":true}`),
			},
		},
		{
			Name:             "go.mod.tidy",
			Description:      "Run go mod tidy to validate and normalize module dependencies.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"check":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace must contain go.mod"},
			Postconditions:   []string{"go.mod/go.sum may be updated"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "go.mod.tidy"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"check":true}`),
			},
		},
		{
			Name:             "go.generate",
			Description:      "Run go generate for a package target.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace must contain go.mod"},
			Postconditions:   []string{"generated files may be updated"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "go.generate"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "go.build",
			Description:      "Compile Go package with restricted build flags and optional output binary name.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"ldflags":{"type":"string"},"output_name":{"type":"string"},"race":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain go.mod"},
			Postconditions:   []string{"build artifacts may be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "go.build"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./cmd/app","output_name":"app","ldflags":"-s -w","race":false}`),
			},
		},
		{
			Name:             "go.test",
			Description:      "Run Go tests with optional coverage and run-pattern filter.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"package":{"type":"string"},"coverage":{"type":"boolean"},"run_pattern":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain go.mod"},
			Postconditions:   []string{"test reports can be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "go.test"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"package":"./...","coverage":true}`),
			},
		},
		{
			Name:             "rust.build",
			Description:      "Compile Rust project/package with cargo build.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"release":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain Cargo.toml"},
			Postconditions:   []string{"target artifacts may be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "rust.build"},
		},
		{
			Name:             "rust.test",
			Description:      "Run Rust tests using cargo test.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain Cargo.toml"},
			Postconditions:   []string{"test output may be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "rust.test"},
		},
		{
			Name:             "rust.clippy",
			Description:      "Run clippy lints for Rust project.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"deny_warnings":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain Cargo.toml"},
			Postconditions:   []string{"lint diagnostics may be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "rust.clippy"},
		},
		{
			Name:             "rust.format",
			Description:      "Run rustfmt in check or write mode.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"check":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace must contain Cargo.toml"},
			Postconditions:   []string{"formatting may be updated"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "rust.format"},
		},
		{
			Name:             "node.install",
			Description:      "Install Node dependencies using npm ci/install.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"use_ci":{"type":"boolean"},"ignore_scripts":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain package.json"},
			Postconditions:   []string{"node_modules may be updated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: "workspace.tools", SpanName: "node.install"},
		},
		{
			Name:             "node.build",
			Description:      "Run Node/TypeScript build script with npm.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain package.json"},
			Postconditions:   []string{"build artifacts may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "target", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "node.build"},
		},
		{
			Name:             "node.test",
			Description:      "Run Node test script with npm.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain package.json"},
			Postconditions:   []string{"test output may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "target", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "node.test"},
		},
		{
			Name:             "node.lint",
			Description:      "Run Node lint script with npm.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 240, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain package.json"},
			Postconditions:   []string{"lint diagnostics may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "target", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "node.lint"},
		},
		{
			Name:             "node.typecheck",
			Description:      "Run TypeScript typecheck script with npm.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 240, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain package.json"},
			Postconditions:   []string{"typecheck diagnostics may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "target", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "node.typecheck"},
		},
		{
			Name:             "python.install_deps",
			Description:      "Install Python dependencies in an isolated venv.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"use_venv":{"type":"boolean"},"requirements_file":{"type":"string"},"constraints_file":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain Python dependency manifest"},
			Postconditions:   []string{"venv and site-packages may be updated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{
					{Field: "requirements_file", WorkspaceRelative: true},
					{Field: "constraints_file", WorkspaceRelative: true},
				},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "python.install_deps"},
		},
		{
			Name:             "python.validate",
			Description:      "Validate Python syntax/bytecode compilation.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace must contain Python sources"},
			Postconditions:   []string{"no repository mutation"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "target", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "python.validate"},
		},
		{
			Name:             "python.test",
			Description:      "Run Python tests with constrained pytest options.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"run_pattern":{"type":"string"},"max_fail":{"type":"integer","minimum":1,"maximum":20}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain pytest-compatible tests"},
			Postconditions:   []string{"test output may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "target", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "python.test"},
		},
		{
			Name:             "c.build",
			Description:      "Compile C source files with constrained compiler options.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"source":{"type":"string"},"output_name":{"type":"string"},"standard":{"type":"string","enum":["c89","c99","c11","c17","c23"]}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace must contain C source files"},
			Postconditions:   []string{"compiled binary may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "source", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "c.build"},
		},
		{
			Name:             "c.test",
			Description:      "Compile and optionally run C test source files.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"source":{"type":"string"},"output_name":{"type":"string"},"standard":{"type":"string","enum":["c89","c99","c11","c17","c23"]},"run":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain C test source files"},
			Postconditions:   []string{"test binary/output may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "source", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: "workspace.tools", SpanName: "c.test"},
		},
	}
}

func mustRawJSON(input string) json.RawMessage {
	return json.RawMessage(input)
}
