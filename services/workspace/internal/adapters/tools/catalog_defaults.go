package tools

import (
	"encoding/json"

	"github.com/underpass-ai/swe-ai-fleet/services/workspace/internal/domain"
)

const (
	// catalogTraceName is the shared OpenTelemetry trace name for all catalog tools.
	catalogTraceName = "workspace.tools"

	// Precondition / postcondition strings reused across many capability entries.
	precondPathInsideAllowedPaths    = "path must be inside allowed_paths"
	postcondNoFilesystemMutation     = "no file system mutation"
	precondWorkspaceSupportedProject = "workspace must contain a supported project type"
	postcondBuildArtifactsGenerated  = "build artifacts may be generated"
	postcondTestReportsGenerated     = "test reports can be generated"
	postcondNoWorkspaceMutation      = "no workspace mutation"
	precondClusterScopeAccess        = "principal must have cluster-scope access"
	postcondNoClusterMutation        = "no cluster mutation"
	precondNamespaceAllowlisted      = "namespace must be allowlisted by policy"
	precondWorkspaceGoMod            = "workspace must contain go.mod"
	precondWorkspaceCargoToml        = "workspace must contain Cargo.toml"
	precondWorkspacePackageJSON      = "workspace must contain package.json"
	postcondTestOutputGenerated              = "test output may be generated"
	postcondNoStateMutation                  = "no state mutation"
	postcondNoRepositoryMutation             = "no repository mutation"
	precondWorkspaceGitRepo                  = "workspace must contain a git repository"
	postcondBoundedMessageBatch             = "bounded message batch returned"
	precondProfileSubjectAllowlisted         = "profile_id and subject must be allowlisted"
	precondProfileTopicAllowlisted           = "profile_id and topic must be allowlisted"
	precondProfileQueueAllowlisted           = "profile_id and queue must be allowlisted"
	precondProfileKeyPrefixAllowlisted       = "profile_id and key prefix must be allowlisted"
	precondRemoteRefspecAllowlisted          = "remote and refspec must be allowlisted by metadata policy"
)

var (
	// catalogTestAllowedPrefix is the shared AllowedPrefix slice for test/run_tests/
	// test_failures_summary/stacktrace_summary capabilities.
	catalogTestAllowedPrefix = []string{
		"-v", "-q", "-race", "-cover", "-coverprofile=", "-run=", "-count=",
		"-timeout=", "--if-present", "--silent", "--maxfail=", "--disable-warnings",
		"--release", "--locked", "--offline", "--features=", "--all-features",
		"--no-default-features", "--package=", "--tests", "-P", "--no-daemon", "-D",
	}
	// catalogTestDeniedPrefix is the shared DeniedPrefix slice for test/run_tests/
	// test_failures_summary/stacktrace_summary capabilities.
	catalogTestDeniedPrefix = []string{
		"-exec", "-toolexec", "-mod=mod", "-modfile", "-buildmode=plugin",
		"-f", "--file", "--require", "--import", "--project-cache-dir",
	}
	// catalogBuildAllowedPrefix is the AllowedPrefix slice for repo.build.
	catalogBuildAllowedPrefix = []string{
		"-v", "-q", "-race", "-trimpath", "-tags=", "-cover", "-coverprofile=", "-run=", "-count=",
		"-timeout=", "--if-present", "--silent", "--maxfail=", "--disable-warnings",
		"--release", "--locked", "--offline", "--features=", "--all-features",
		"--no-default-features", "--package=", "--tests", "-P", "--no-daemon", "-D",
	}
	// catalogShellDenyChars is the shared DenyCharacters list for shell-injection prevention.
	catalogShellDenyChars          = []string{";", "|", "&", "`", "$(", ">", "<", "\n", "\r"}
	catalogShellDenyCharsWithSpace = []string{";", "|", "&", "`", "$(", ">", "<", "\n", "\r", " "}
	// catalogLangToolOutputSchema is the shared OutputSchema for language-specific toolchain tools.
	catalogLangToolOutputSchema = mustRawJSON(`{"type":"object","properties":{"exit_code":{"type":"integer"},"compiled_binary_path":{"type":"string"},"coverage_percent":{"type":"number"},"diagnostics":{"type":"array","items":{"type":"string"}}}}`)
)

func newExtraArgsPolicy(allowed, denied []string) domain.PolicyMetadata {
	return domain.PolicyMetadata{
		ArgFields: []domain.PolicyArgField{
			{
				Field:          "extra_args",
				Multi:          true,
				MaxItems:       8,
				MaxLength:      64,
				AllowedPrefix:  allowed,
				DeniedPrefix:   denied,
				DenyCharacters: catalogShellDenyChars,
			},
		},
	}
}

func newGitRemoteDenyPolicy() domain.PolicyMetadata {
	return domain.PolicyMetadata{
		ArgFields: []domain.PolicyArgField{
			{Field: "remote", MaxLength: 128, DenyCharacters: catalogShellDenyCharsWithSpace},
			{Field: "refspec", MaxLength: 512, DenyCharacters: catalogShellDenyCharsWithSpace},
		},
	}
}

func newK8sReadCapability(name, desc, spanName string, inputSchema, outputSchema json.RawMessage, examples []json.RawMessage) domain.Capability {
	return domain.Capability{
		Name:             name,
		Description:      desc,
		InputSchema:      inputSchema,
		OutputSchema:     outputSchema,
		Scope:            domain.ScopeCluster,
		SideEffects:      domain.SideEffectsNone,
		RiskLevel:        domain.RiskLow,
		RequiresApproval: false,
		Idempotency:      domain.IdempotencyGuaranteed,
		Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
		Preconditions:    []string{precondClusterScopeAccess},
		Postconditions:   []string{postcondNoClusterMutation},
		CostHint:         "low",
		Policy: domain.PolicyMetadata{
			NamespaceFields: []string{"namespace"},
		},
		Observability: domain.Observability{TraceName: catalogTraceName, SpanName: spanName},
		Examples:      examples,
	}
}

func newGoCapability(name, desc, spanName string, inputSchema json.RawMessage, postconds []string, examples []json.RawMessage) domain.Capability {
	return domain.Capability{
		Name:             name,
		Description:      desc,
		InputSchema:      inputSchema,
		OutputSchema:     catalogLangToolOutputSchema,
		Scope:            domain.ScopeRepo,
		SideEffects:      domain.SideEffectsReversible,
		RiskLevel:        domain.RiskMedium,
		RequiresApproval: false,
		Idempotency:      domain.IdempotencyBestEffort,
		Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
		Preconditions:    []string{precondWorkspaceGoMod},
		Postconditions:   postconds,
		CostHint:         "high",
		Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: spanName},
		Examples:         examples,
	}
}

func newRustCapability(name, desc, spanName string, inputSchema json.RawMessage, postconds []string, costHint string, timeout int) domain.Capability {
	return domain.Capability{
		Name:             name,
		Description:      desc,
		InputSchema:      inputSchema,
		OutputSchema:     catalogLangToolOutputSchema,
		Scope:            domain.ScopeRepo,
		SideEffects:      domain.SideEffectsReversible,
		RiskLevel:        domain.RiskMedium,
		RequiresApproval: false,
		Idempotency:      domain.IdempotencyBestEffort,
		Constraints:      domain.Constraints{TimeoutSeconds: timeout, MaxRetries: 0, OutputLimitKB: 2048},
		Preconditions:    []string{precondWorkspaceCargoToml},
		Postconditions:   postconds,
		CostHint:         costHint,
		Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: spanName},
	}
}

func newNodeCapability(name, desc, spanName string, inputSchema json.RawMessage, postconds []string, costHint string, timeout, outputKB int) domain.Capability {
	return domain.Capability{
		Name:             name,
		Description:      desc,
		InputSchema:      inputSchema,
		OutputSchema:     catalogLangToolOutputSchema,
		Scope:            domain.ScopeRepo,
		SideEffects:      domain.SideEffectsReversible,
		RiskLevel:        domain.RiskMedium,
		RequiresApproval: false,
		Idempotency:      domain.IdempotencyBestEffort,
		Constraints:      domain.Constraints{TimeoutSeconds: timeout, MaxRetries: 0, OutputLimitKB: outputKB},
		Preconditions:    []string{precondWorkspacePackageJSON},
		Postconditions:   postconds,
		CostHint:         costHint,
		Policy: domain.PolicyMetadata{
			PathFields: []domain.PolicyPathField{{Field: "target", WorkspaceRelative: true}},
		},
		Observability: domain.Observability{TraceName: catalogTraceName, SpanName: spanName},
	}
}

func DefaultCapabilities() []domain.Capability {
	return []domain.Capability{
		{
			Name:             "fs.list",
			Description:      "List files/directories under the session workspace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"recursive":{"type":"boolean"},"max_entries":{"type":"integer","minimum":1,"maximum":1000}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"entries":{"type":"array"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 15, MaxRetries: 0, OutputLimitKB: 256},
			Preconditions:    []string{precondPathInsideAllowedPaths},
			Postconditions:   []string{postcondNoFilesystemMutation},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "fs.list"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","recursive":false}`),
			},
		},
		{
			Name:             "fs.read_file",
			Description:      "Read a text or binary file from workspace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576}},"required":["path"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"content":{"type":"string"},"encoding":{"type":"string"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"path must be inside allowed_paths and point to a regular file"},
			Postconditions:   []string{postcondNoFilesystemMutation},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "fs.read_file"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":"README.md"}`),
			},
		},
		{
			Name:             "fs.write_file",
			Description:      "Write a file in workspace using UTF-8 or base64 payload.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"content":{"type":"string"},"encoding":{"type":"string","enum":["utf8","base64"]},"create_parents":{"type":"boolean"}},"required":["path","content"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"bytes_written":{"type":"integer"},"sha256":{"type":"string"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 256},
			Preconditions:    []string{precondPathInsideAllowedPaths},
			Postconditions:   []string{"target file updated"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "fs.write_file"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":"notes/todo.txt","content":"hello","create_parents":true}`),
			},
		},
		{
			Name:             "fs.mkdir",
			Description:      "Create a directory inside workspace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"create_parents":{"type":"boolean"},"mode":{"type":"string"},"exist_ok":{"type":"boolean"}},"required":["path"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"created":{"type":"boolean"},"mode":{"type":"string"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 64},
			Preconditions:    []string{precondPathInsideAllowedPaths},
			Postconditions:   []string{"directory may be created"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "fs.mkdir"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":"tmp/output","create_parents":true,"mode":"0755","exist_ok":true}`),
			},
		},
		{
			Name:             "fs.move",
			Description:      "Move or rename a file/directory inside workspace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"source_path":{"type":"string"},"destination_path":{"type":"string"},"overwrite":{"type":"boolean"},"create_parents":{"type":"boolean"}},"required":["source_path","destination_path"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"source_path":{"type":"string"},"destination_path":{"type":"string"},"moved":{"type":"boolean"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 64},
			Preconditions:    []string{"source and destination must be inside allowed_paths"},
			Postconditions:   []string{"source path may be relocated"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{
					{Field: "source_path", WorkspaceRelative: true},
					{Field: "destination_path", WorkspaceRelative: true},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "fs.move"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"source_path":"tmp/file.txt","destination_path":"tmp/archive/file.txt","overwrite":true,"create_parents":true}`),
			},
		},
		{
			Name:             "fs.copy",
			Description:      "Copy a file/directory inside workspace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"source_path":{"type":"string"},"destination_path":{"type":"string"},"recursive":{"type":"boolean"},"overwrite":{"type":"boolean"},"create_parents":{"type":"boolean"}},"required":["source_path","destination_path"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"source_path":{"type":"string"},"destination_path":{"type":"string"},"copied":{"type":"boolean"},"type":{"type":"string"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 25, MaxRetries: 0, OutputLimitKB: 64},
			Preconditions:    []string{"source and destination must be inside allowed_paths"},
			Postconditions:   []string{"destination path may be created/updated"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{
					{Field: "source_path", WorkspaceRelative: true},
					{Field: "destination_path", WorkspaceRelative: true},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "fs.copy"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"source_path":"notes/todo.txt","destination_path":"notes/todo.copy.txt","overwrite":true}`),
			},
		},
		{
			Name:             "fs.delete",
			Description:      "Delete a file/directory inside workspace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"recursive":{"type":"boolean"},"force":{"type":"boolean"}},"required":["path"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"deleted":{"type":"boolean"},"existed":{"type":"boolean"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsIrreversible,
			RiskLevel:        domain.RiskHigh,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 64},
			Preconditions:    []string{"path must be inside allowed_paths and must not be workspace root"},
			Postconditions:   []string{"target path may be removed"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "fs.delete"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":"tmp/old.log","recursive":false,"force":true}`),
			},
		},
		{
			Name:             "fs.stat",
			Description:      "Get metadata (type, size, mode, mtime) for a workspace path.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"}},"required":["path"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"exists":{"type":"boolean"},"type":{"type":"string"},"size_bytes":{"type":"integer"},"mode":{"type":"string"},"modified_at":{"type":"string"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 15, MaxRetries: 0, OutputLimitKB: 64},
			Preconditions:    []string{precondPathInsideAllowedPaths},
			Postconditions:   []string{postcondNoFilesystemMutation},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "fs.stat"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":"README.md"}`),
			},
		},
		{
			Name:             "fs.patch",
			Description:      "Apply a unified diff patch to files in the workspace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"unified_diff":{"type":"string"},"strategy":{"type":"string","enum":["apply","reject_on_conflict"]}},"required":["unified_diff"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"applied":{"type":"boolean"},"strategy":{"type":"string"},"changed_paths":{"type":"array","items":{"type":"string"}},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 45, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"patch paths must be inside allowed_paths"},
			Postconditions:   []string{"workspace files may change"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: "fs.patch"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"unified_diff":"diff --git a/file b/file\n...","strategy":"reject_on_conflict"}`),
			},
		},
		{
			Name:             "fs.search",
			Description:      "Search file contents using regex pattern.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"pattern":{"type":"string"},"max_results":{"type":"integer","minimum":1,"maximum":2000}},"required":["pattern"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"matches":{"type":"array"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 512},
			Preconditions:    []string{precondPathInsideAllowedPaths},
			Postconditions:   []string{postcondNoFilesystemMutation},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "fs.search"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","pattern":"TODO","max_results":50}`),
			},
		},
		{
			Name:             "conn.list_profiles",
			Description:      "List governable external connection profiles visible to the session principal.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profiles":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string"},"kind":{"type":"string"},"description":{"type":"string"},"read_only":{"type":"boolean"},"scopes":{"type":"object"}}}},"count":{"type":"integer"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 10, MaxRetries: 0, OutputLimitKB: 256},
			Preconditions:    []string{"session metadata may restrict allowed profiles"},
			Postconditions:   []string{postcondNoStateMutation},
			CostHint:         "low",
			Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: "conn.list_profiles"},
			Examples: []json.RawMessage{
				mustRawJSON(`{}`),
			},
		},
		{
			Name:             "conn.describe_profile",
			Description:      "Describe a specific connection profile (without exposing credentials).",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"}},"required":["profile_id"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile":{"type":"object","properties":{"id":{"type":"string"},"kind":{"type":"string"},"description":{"type":"string"},"read_only":{"type":"boolean"},"scopes":{"type":"object"}}}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 10, MaxRetries: 0, OutputLimitKB: 128},
			Preconditions:    []string{"profile_id must refer to a visible profile"},
			Postconditions:   []string{postcondNoStateMutation},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "conn.describe_profile"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.redis"}`),
			},
		},
		{
			Name:             "api.benchmark",
			Description:      "Run a bounded k6 benchmark against an allowlisted HTTP profile route.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"request":{"type":"object","properties":{"method":{"type":"string","enum":["GET","HEAD","OPTIONS","POST","PUT","PATCH","DELETE"]},"path":{"type":"string"},"headers":{"type":"object","additionalProperties":{"type":"string"}},"body":{"type":"string"}},"required":["path"]},"load":{"type":"object","properties":{"mode":{"type":"string","enum":["constant_vus","arrival_rate"]},"duration_ms":{"type":"integer","minimum":100,"maximum":60000},"vus":{"type":"integer","minimum":1,"maximum":50},"rps":{"type":"integer","minimum":1,"maximum":200}}},"thresholds":{"type":"object","properties":{"p95_ms":{"type":"number","minimum":1},"error_rate":{"type":"number","minimum":0,"maximum":1},"checks":{"type":"number","minimum":0,"maximum":1}}},"include_raw_metrics":{"type":"boolean"}},"required":["profile_id","request"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"target_url":{"type":"string"},"request":{"type":"object"},"load":{"type":"object"},"latency_ms":{"type":"object","properties":{"min":{"type":"number"},"avg":{"type":"number"},"p50":{"type":"number"},"p95":{"type":"number"},"p99":{"type":"number"},"max":{"type":"number"}}},"rps_observed":{"type":"number"},"requests":{"type":"integer"},"failed_requests":{"type":"integer"},"error_rate":{"type":"number"},"http_codes":{"type":"object"},"thresholds":{"type":"object","properties":{"passed":{"type":"boolean"},"violations":{"type":"array","items":{"type":"string"}}}},"artifacts":{"type":"object"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 120, MaxRetries: 0, OutputLimitKB: 4096},
			Preconditions:    []string{"profile_id must be an allowlisted http/api profile", "request.path must be allowlisted by profile routes"},
			Postconditions:   []string{"k6 benchmark executed with bounded load", "benchmark artifacts may be generated"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				ArgFields: []domain.PolicyArgField{
					{
						Field:          "request.path",
						MaxLength:      2048,
						AllowedPrefix:  []string{"/"},
						DeniedPrefix:   []string{"http://", "https://"},
						DenyCharacters: []string{"\n", "\r"},
					},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "api.benchmark"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"bench.workspace","request":{"method":"GET","path":"/healthz","headers":{"accept":"application/json"}},"load":{"mode":"constant_vus","duration_ms":10000,"vus":5},"thresholds":{"p95_ms":1000,"error_rate":0.05,"checks":0.95}}`),
			},
		},
		{
			Name:             "nats.request",
			Description:      "Send NATS request/reply call with profile-governed subject limits.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"subject":{"type":"string"},"payload":{"type":"string"},"payload_encoding":{"type":"string","enum":["utf8","base64"]},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576}},"required":["profile_id","subject"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"subject":{"type":"string"},"response_base64":{"type":"string"},"response_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{precondProfileSubjectAllowlisted},
			Postconditions:   []string{"request-reply interaction completed"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				SubjectFields: []domain.PolicySubjectField{{Field: "subject"}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "nats.request"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.nats","subject":"sandbox.echo","payload":"hello","payload_encoding":"utf8","timeout_ms":2000}`),
			},
		},
		{
			Name:             "nats.publish",
			Description:      "Publish NATS message to an allowlisted subject.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"subject":{"type":"string"},"payload":{"type":"string"},"payload_encoding":{"type":"string","enum":["utf8","base64"]},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576}},"required":["profile_id","subject"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"subject":{"type":"string"},"payload_bytes":{"type":"integer"},"payload_encoding":{"type":"string"},"published":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 256},
			Preconditions:    []string{precondProfileSubjectAllowlisted},
			Postconditions:   []string{"message may be published"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				SubjectFields: []domain.PolicySubjectField{{Field: "subject"}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "nats.publish"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.nats","subject":"sandbox.events","payload":"hello","payload_encoding":"utf8","timeout_ms":2000}`),
			},
		},
		{
			Name:             "nats.subscribe_pull",
			Description:      "Pull messages from NATS subject with deterministic limits.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"subject":{"type":"string"},"max_messages":{"type":"integer","minimum":1,"maximum":100},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","subject"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"subject":{"type":"string"},"messages":{"type":"array","items":{"type":"object","properties":{"subject":{"type":"string"},"data_base64":{"type":"string"},"size_bytes":{"type":"integer"},"data_trimmed":{"type":"boolean"}}}},"message_count":{"type":"integer"},"total_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{precondProfileSubjectAllowlisted},
			Postconditions:   []string{postcondBoundedMessageBatch},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				SubjectFields: []domain.PolicySubjectField{{Field: "subject"}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "nats.subscribe_pull"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.nats","subject":"sandbox.events","max_messages":20,"timeout_ms":2000}`),
			},
		},
		{
			Name:             "kafka.consume",
			Description:      "Consume Kafka messages from an allowlisted topic with bounded output.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"topic":{"type":"string"},"partition":{"type":"integer","minimum":0},"offset_mode":{"type":"string","enum":["earliest","latest","absolute","timestamp"]},"offset":{"oneOf":[{"type":"integer","minimum":0},{"type":"string","enum":["earliest","latest"]}]},"timestamp_ms":{"type":"integer","minimum":0},"max_messages":{"type":"integer","minimum":1,"maximum":200},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","topic"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"topic":{"type":"string"},"offset_mode":{"type":"string"},"offset":{"type":"integer"},"timestamp_ms":{"type":"integer"},"messages":{"type":"array","items":{"type":"object","properties":{"partition":{"type":"integer"},"offset":{"type":"integer"},"timestamp_unix":{"type":"integer"},"key_base64":{"type":"string"},"value_base64":{"type":"string"},"size_bytes":{"type":"integer"},"key_trimmed":{"type":"boolean"},"value_trimmed":{"type":"boolean"}}}},"message_count":{"type":"integer"},"total_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{precondProfileTopicAllowlisted},
			Postconditions:   []string{postcondBoundedMessageBatch},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				TopicFields:   []domain.PolicyTopicField{{Field: "topic"}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "kafka.consume"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.kafka","topic":"sandbox.events","partition":0,"offset_mode":"latest","max_messages":20,"timeout_ms":2000}`),
				mustRawJSON(`{"profile_id":"dev.kafka","topic":"sandbox.events","partition":0,"offset_mode":"absolute","offset":42,"max_messages":20,"timeout_ms":2000}`),
				mustRawJSON(`{"profile_id":"dev.kafka","topic":"sandbox.events","partition":0,"offset_mode":"timestamp","timestamp_ms":1730000000000,"max_messages":20,"timeout_ms":2000}`),
			},
		},
		{
			Name:             "kafka.produce",
			Description:      "Produce Kafka message to an allowlisted topic.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"topic":{"type":"string"},"partition":{"type":"integer","minimum":0},"key":{"type":"string"},"key_encoding":{"type":"string","enum":["utf8","base64"]},"value":{"type":"string"},"value_encoding":{"type":"string","enum":["utf8","base64"]},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576}},"required":["profile_id","topic"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"topic":{"type":"string"},"partition":{"type":"integer"},"key_bytes":{"type":"integer"},"value_bytes":{"type":"integer"},"produced":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 256},
			Preconditions:    []string{precondProfileTopicAllowlisted},
			Postconditions:   []string{"message may be produced"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				TopicFields:   []domain.PolicyTopicField{{Field: "topic"}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "kafka.produce"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.kafka","topic":"sandbox.events","partition":0,"key":"k1","value":"hello","value_encoding":"utf8","timeout_ms":2000}`),
			},
		},
		{
			Name:             "kafka.topic_metadata",
			Description:      "Describe Kafka topic metadata for an allowlisted topic.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"topic":{"type":"string"}},"required":["profile_id","topic"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"topic":{"type":"string"},"partition_count":{"type":"integer"},"partitions":{"type":"array","items":{"type":"object","properties":{"partition":{"type":"integer"},"leader_host":{"type":"string"},"leader_port":{"type":"integer"},"replica_ids":{"type":"array","items":{"type":"integer"}},"isr_ids":{"type":"array","items":{"type":"integer"}},"replica_count":{"type":"integer"},"isr_count":{"type":"integer"}}}}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 512},
			Preconditions:    []string{precondProfileTopicAllowlisted},
			Postconditions:   []string{postcondNoStateMutation},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				TopicFields:   []domain.PolicyTopicField{{Field: "topic"}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "kafka.topic_metadata"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.kafka","topic":"sandbox.events"}`),
			},
		},
		{
			Name:             "rabbit.consume",
			Description:      "Consume RabbitMQ messages from an allowlisted queue with bounded output.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"queue":{"type":"string"},"max_messages":{"type":"integer","minimum":1,"maximum":200},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","queue"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"queue":{"type":"string"},"messages":{"type":"array","items":{"type":"object","properties":{"exchange":{"type":"string"},"routing_key":{"type":"string"},"redelivered":{"type":"boolean"},"timestamp_unix":{"type":"integer"},"body_base64":{"type":"string"},"size_bytes":{"type":"integer"},"body_trimmed":{"type":"boolean"}}}},"message_count":{"type":"integer"},"total_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{precondProfileQueueAllowlisted},
			Postconditions:   []string{postcondBoundedMessageBatch},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				QueueFields:   []domain.PolicyQueueField{{Field: "queue"}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "rabbit.consume"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.rabbit","queue":"sandbox.jobs","max_messages":20,"timeout_ms":2000}`),
			},
		},
		{
			Name:             "rabbit.publish",
			Description:      "Publish RabbitMQ message to an allowlisted queue/routing key.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"queue":{"type":"string"},"exchange":{"type":"string"},"routing_key":{"type":"string"},"payload":{"type":"string"},"payload_encoding":{"type":"string","enum":["utf8","base64"]},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576}},"required":["profile_id","queue"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"queue":{"type":"string"},"exchange":{"type":"string"},"routing_key":{"type":"string"},"payload_bytes":{"type":"integer"},"published":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 256},
			Preconditions:    []string{precondProfileQueueAllowlisted},
			Postconditions:   []string{"message may be published"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				QueueFields:   []domain.PolicyQueueField{{Field: "queue"}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "rabbit.publish"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.rabbit","queue":"sandbox.jobs","payload":"hello","payload_encoding":"utf8","timeout_ms":2000}`),
			},
		},
		{
			Name:             "rabbit.queue_info",
			Description:      "Inspect RabbitMQ queue metrics for an allowlisted queue.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"queue":{"type":"string"},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","queue"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"queue":{"type":"string"},"messages":{"type":"integer"},"consumers":{"type":"integer"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 256},
			Preconditions:    []string{precondProfileQueueAllowlisted},
			Postconditions:   []string{postcondNoStateMutation},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
				QueueFields:   []domain.PolicyQueueField{{Field: "queue"}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "rabbit.queue_info"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.rabbit","queue":"sandbox.jobs"}`),
			},
		},
		{
			Name:             "redis.get",
			Description:      "Read a single Redis key from an allowlisted key prefix.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"key":{"type":"string"},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","key"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"key":{"type":"string"},"found":{"type":"boolean"},"value_base64":{"type":"string"},"value_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 15, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{precondProfileKeyPrefixAllowlisted},
			Postconditions:   []string{postcondNoStateMutation},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields:   []domain.PolicyProfileField{{Field: "profile_id"}},
				KeyPrefixFields: []domain.PolicyKeyPrefixField{{Field: "key"}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "redis.get"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.redis","key":"sandbox:todo:1","max_bytes":4096}`),
			},
		},
		{
			Name:             "redis.mget",
			Description:      "Read multiple Redis keys from allowlisted key prefixes.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"keys":{"type":"array","items":{"type":"string"},"minItems":1,"maxItems":200},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","keys"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"entries":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"found":{"type":"boolean"},"value_base64":{"type":"string"},"value_bytes":{"type":"integer"},"value_trimmed":{"type":"boolean"}}}},"key_count":{"type":"integer"},"found_count":{"type":"integer"},"total_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"profile_id and all key prefixes must be allowlisted"},
			Postconditions:   []string{postcondNoStateMutation},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields:   []domain.PolicyProfileField{{Field: "profile_id"}},
				KeyPrefixFields: []domain.PolicyKeyPrefixField{{Field: "keys", Multi: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "redis.mget"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.redis","keys":["sandbox:todo:1","sandbox:todo:2"]}`),
			},
		},
		{
			Name:             "redis.scan",
			Description:      "Scan Redis keys under an allowlisted prefix with deterministic bounds.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"prefix":{"type":"string"},"cursor":{"type":"integer","minimum":0},"max_keys":{"type":"integer","minimum":1,"maximum":1000},"count_hint":{"type":"integer","minimum":1,"maximum":1000},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","prefix"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"prefix":{"type":"string"},"keys":{"type":"array","items":{"type":"string"}},"count":{"type":"integer"},"next_cursor":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"profile_id and prefix must be allowlisted"},
			Postconditions:   []string{postcondNoStateMutation},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields:   []domain.PolicyProfileField{{Field: "profile_id"}},
				KeyPrefixFields: []domain.PolicyKeyPrefixField{{Field: "prefix"}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "redis.scan"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.redis","prefix":"sandbox:todo:","max_keys":100}`),
			},
		},
		{
			Name:             "redis.ttl",
			Description:      "Get TTL metadata for a Redis key in an allowlisted prefix.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"key":{"type":"string"},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","key"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"key":{"type":"string"},"exists":{"type":"boolean"},"status":{"type":"string"},"ttl_seconds":{"type":"integer"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 15, MaxRetries: 0, OutputLimitKB: 128},
			Preconditions:    []string{precondProfileKeyPrefixAllowlisted},
			Postconditions:   []string{postcondNoStateMutation},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields:   []domain.PolicyProfileField{{Field: "profile_id"}},
				KeyPrefixFields: []domain.PolicyKeyPrefixField{{Field: "key"}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "redis.ttl"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.redis","key":"sandbox:todo:1"}`),
			},
		},
		{
			Name:             "redis.exists",
			Description:      "Check existence for Redis keys in allowlisted prefixes.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"keys":{"type":"array","items":{"type":"string"},"minItems":1,"maxItems":200},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","keys"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"keys_checked":{"type":"integer"},"exists_count":{"type":"integer"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 15, MaxRetries: 0, OutputLimitKB: 128},
			Preconditions:    []string{"profile_id and key prefixes must be allowlisted"},
			Postconditions:   []string{postcondNoStateMutation},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields:   []domain.PolicyProfileField{{Field: "profile_id"}},
				KeyPrefixFields: []domain.PolicyKeyPrefixField{{Field: "keys", Multi: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "redis.exists"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.redis","keys":["sandbox:todo:1","sandbox:todo:2"]}`),
			},
		},
		{
			Name:             "redis.set",
			Description:      "Set a Redis key with mandatory TTL in an allowlisted prefix.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"key":{"type":"string"},"value":{"type":"string"},"value_encoding":{"type":"string","enum":["utf8","base64"]},"ttl_seconds":{"type":"integer","minimum":1,"maximum":604800},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","key","value","ttl_seconds"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"key":{"type":"string"},"ttl_seconds":{"type":"integer"},"value_bytes":{"type":"integer"},"value_format":{"type":"string"},"written":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 15, MaxRetries: 0, OutputLimitKB: 128},
			Preconditions:    []string{precondProfileKeyPrefixAllowlisted, "ttl_seconds is required", "explicit approval required"},
			Postconditions:   []string{"key value updated with ttl"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields:   []domain.PolicyProfileField{{Field: "profile_id"}},
				KeyPrefixFields: []domain.PolicyKeyPrefixField{{Field: "key"}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "redis.set"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.redis","key":"sandbox:todo:1","value":"{\"title\":\"demo\"}","ttl_seconds":3600}`),
			},
		},
		{
			Name:             "redis.del",
			Description:      "Delete Redis keys from allowlisted prefixes.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"keys":{"type":"array","items":{"type":"string"},"minItems":1,"maxItems":200},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","keys"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"keys_requested":{"type":"integer"},"deleted":{"type":"integer"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsIrreversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 15, MaxRetries: 0, OutputLimitKB: 128},
			Preconditions:    []string{"profile_id and key prefixes must be allowlisted", "explicit approval required"},
			Postconditions:   []string{"keys may be deleted"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ProfileFields:   []domain.PolicyProfileField{{Field: "profile_id"}},
				KeyPrefixFields: []domain.PolicyKeyPrefixField{{Field: "keys", Multi: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "redis.del"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.redis","keys":["sandbox:todo:1","sandbox:todo:2"]}`),
			},
		},
		{
			Name:             "mongo.find",
			Description:      "Find MongoDB documents from an allowlisted database with a hard result limit.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"database":{"type":"string"},"collection":{"type":"string"},"filter":{"type":"object"},"projection":{"type":"object"},"sort":{"type":"object"},"limit":{"type":"integer","minimum":1,"maximum":200},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","database","collection"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"database":{"type":"string"},"collection":{"type":"string"},"documents":{"type":"array","items":{"type":"object"}},"document_count":{"type":"integer"},"effective_limit":{"type":"integer"},"total_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"profile_id and database must be allowlisted"},
			Postconditions:   []string{postcondNoStateMutation},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "mongo.find"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.mongo","database":"sandbox","collection":"todos","filter":{"status":"open"},"limit":50}`),
			},
		},
		{
			Name:             "mongo.aggregate",
			Description:      "Run MongoDB aggregation with a server-side hard result limit.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"database":{"type":"string"},"collection":{"type":"string"},"pipeline":{"type":"array","items":{"type":"object"}},"limit":{"type":"integer","minimum":1,"maximum":200},"max_bytes":{"type":"integer","minimum":1,"maximum":1048576},"timeout_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["profile_id","database","collection"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"profile_id":{"type":"string"},"database":{"type":"string"},"collection":{"type":"string"},"documents":{"type":"array","items":{"type":"object"}},"document_count":{"type":"integer"},"effective_limit":{"type":"integer"},"total_bytes":{"type":"integer"},"truncated":{"type":"boolean"}}}`),
			Scope:            domain.ScopeExternal,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"profile_id and database must be allowlisted"},
			Postconditions:   []string{postcondNoStateMutation},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ProfileFields: []domain.PolicyProfileField{{Field: "profile_id"}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "mongo.aggregate"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"profile_id":"dev.mongo","database":"sandbox","collection":"todos","pipeline":[{"$match":{"status":"done"}}],"limit":50}`),
			},
		},
		{
			Name:             "git.status",
			Description:      "Run git status in the workspace repository.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"short":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"status":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 1, OutputLimitKB: 256},
			Preconditions:    []string{precondWorkspaceGitRepo},
			Postconditions:   []string{postcondNoRepositoryMutation},
			CostHint:         "low",
			Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: "git.status"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"short":true}`),
			},
		},
		{
			Name:             "git.diff",
			Description:      "Return unified diff from git workspace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"staged":{"type":"boolean"},"paths":{"type":"array","items":{"type":"string"}},"base":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"diff":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 1, OutputLimitKB: 1024},
			Preconditions:    []string{precondWorkspaceGitRepo},
			Postconditions:   []string{postcondNoRepositoryMutation},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "paths", Multi: true, WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "git.diff"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"staged":false}`),
			},
		},
		{
			Name:             "git.apply_patch",
			Description:      "Apply a unified diff patch using git apply.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"patch":{"type":"string"},"check":{"type":"boolean"}},"required":["patch"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"applied":{"type":"boolean"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 45, MaxRetries: 0, OutputLimitKB: 512},
			Preconditions:    []string{precondWorkspaceGitRepo},
			Postconditions:   []string{"working tree may change"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: "git.apply_patch"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"patch":"diff --git ...","check":true}`),
			},
		},
		{
			Name:             "git.checkout",
			Description:      "Checkout a branch or ref, optionally creating a new branch.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"ref":{"type":"string"},"create":{"type":"boolean"},"start_point":{"type":"string"},"force":{"type":"boolean"}},"required":["ref"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"ref":{"type":"string"},"created":{"type":"boolean"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 512},
			Preconditions:    []string{precondWorkspaceGitRepo},
			Postconditions:   []string{"checked out ref may change working tree"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ArgFields: []domain.PolicyArgField{
					{Field: "ref", MaxLength: 256, DenyCharacters: []string{";", "|", "&", "`", "$(", ">", "<", "\n", "\r"}},
					{Field: "start_point", MaxLength: 256, DenyCharacters: []string{";", "|", "&", "`", "$(", ">", "<", "\n", "\r"}},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "git.checkout"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"ref":"feature/new-api"}`),
				mustRawJSON(`{"ref":"release-2026-02","create":true,"start_point":"origin/main"}`),
			},
		},
		{
			Name:             "git.log",
			Description:      "List commit history for a ref with bounded output.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"ref":{"type":"string"},"max_count":{"type":"integer","minimum":1,"maximum":200}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"ref":{"type":"string"},"count":{"type":"integer"},"entries":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string"},"author_name":{"type":"string"},"author_email":{"type":"string"},"date":{"type":"string"},"subject":{"type":"string"},"parents":{"type":"array","items":{"type":"string"}}}}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 1, OutputLimitKB: 1024},
			Preconditions:    []string{precondWorkspaceGitRepo},
			Postconditions:   []string{postcondNoRepositoryMutation},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ArgFields: []domain.PolicyArgField{
					{Field: "ref", MaxLength: 256, DenyCharacters: []string{";", "|", "&", "`", "$(", ">", "<", "\n", "\r"}},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "git.log"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"ref":"HEAD","max_count":20}`),
			},
		},
		{
			Name:             "git.show",
			Description:      "Show commit details or file content at a ref.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"ref":{"type":"string"},"path":{"type":"string"},"stat":{"type":"boolean"},"patch":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"ref":{"type":"string"},"path":{"type":"string"},"show":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 1, OutputLimitKB: 1024},
			Preconditions:    []string{precondWorkspaceGitRepo},
			Postconditions:   []string{postcondNoRepositoryMutation},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
				ArgFields: []domain.PolicyArgField{
					{Field: "ref", MaxLength: 256, DenyCharacters: []string{";", "|", "&", "`", "$(", ">", "<", "\n", "\r"}},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "git.show"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"ref":"HEAD~1"}`),
				mustRawJSON(`{"ref":"HEAD","path":"README.md","patch":false}`),
			},
		},
		{
			Name:             "git.branch_list",
			Description:      "List local and/or remote branches.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"all":{"type":"boolean"},"remotes":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"count":{"type":"integer"},"branches":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"upstream":{"type":"string"},"commit":{"type":"string"},"current":{"type":"boolean"}}}}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 1, OutputLimitKB: 512},
			Preconditions:    []string{precondWorkspaceGitRepo},
			Postconditions:   []string{postcondNoRepositoryMutation},
			CostHint:         "low",
			Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: "git.branch_list"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"all":true}`),
			},
		},
		{
			Name:             "git.commit",
			Description:      "Create a commit from staged changes or selected paths.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"message":{"type":"string"},"all":{"type":"boolean"},"paths":{"type":"array","items":{"type":"string"}}},"required":["message"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"committed":{"type":"boolean"},"commit":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsIrreversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyNone,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 512},
			Preconditions:    []string{"workspace must contain a git repository and staged changes"},
			Postconditions:   []string{"new commit may be created"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "paths", Multi: true, WorkspaceRelative: true}},
				ArgFields: []domain.PolicyArgField{
					{Field: "message", MaxLength: 1024, DenyCharacters: []string{"\u0000"}},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "git.commit"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"message":"feat: add workspace policy guard","all":true}`),
			},
		},
		{
			Name:             "git.push",
			Description:      "Push commits to an allowlisted remote/refspec.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"remote":{"type":"string"},"refspec":{"type":"string"},"set_upstream":{"type":"boolean"},"force_with_lease":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"remote":{"type":"string"},"refspec":{"type":"string"},"pushed":{"type":"boolean"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsIrreversible,
			RiskLevel:        domain.RiskHigh,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 60, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{precondRemoteRefspecAllowlisted},
			Postconditions:   []string{"remote repository may be mutated"},
			CostHint:         "high",
			Policy:        newGitRemoteDenyPolicy(),
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "git.push"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"remote":"origin","refspec":"HEAD:refs/heads/feature/new-api","set_upstream":true}`),
			},
		},
		{
			Name:             "git.fetch",
			Description:      "Fetch refs from an allowlisted remote/refspec.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"remote":{"type":"string"},"refspec":{"type":"string"},"prune":{"type":"boolean"},"tags":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"remote":{"type":"string"},"refspec":{"type":"string"},"fetched":{"type":"boolean"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 60, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{precondRemoteRefspecAllowlisted},
			Postconditions:   []string{"remote-tracking refs may change"},
			CostHint:         "medium",
			Policy:        newGitRemoteDenyPolicy(),
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "git.fetch"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"remote":"origin","refspec":"refs/heads/main","prune":true}`),
			},
		},
		{
			Name:             "git.pull",
			Description:      "Pull from an allowlisted remote/refspec.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"remote":{"type":"string"},"refspec":{"type":"string"},"rebase":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"remote":{"type":"string"},"refspec":{"type":"string"},"pulled":{"type":"boolean"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 60, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{precondRemoteRefspecAllowlisted},
			Postconditions:   []string{"local branch may change"},
			CostHint:         "medium",
			Policy:        newGitRemoteDenyPolicy(),
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "git.pull"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"remote":"origin","refspec":"main","rebase":true}`),
			},
		},
		{
			Name:             "repo.detect_project_type",
			Description:      "Detect repository project type for build/test orchestration.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"flavor":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 15, MaxRetries: 0, OutputLimitKB: 64},
			Preconditions:    []string{"workspace must be initialized"},
			Postconditions:   []string{postcondNoRepositoryMutation},
			CostHint:         "low",
			Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: "repo.detect_project_type"},
			Examples: []json.RawMessage{
				mustRawJSON(`{}`),
			},
		},
		{
			Name:             "repo.detect_toolchain",
			Description:      "Detect language toolchain metadata for orchestration.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"language":{"type":"string"},"build_system":{"type":"string"},"test_framework":{"type":"string"},"containerizable":{"type":"boolean"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 20, MaxRetries: 0, OutputLimitKB: 64},
			Preconditions:    []string{"workspace must be initialized"},
			Postconditions:   []string{postcondNoRepositoryMutation},
			CostHint:         "low",
			Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: "repo.detect_toolchain"},
			Examples: []json.RawMessage{
				mustRawJSON(`{}`),
			},
		},
		{
			Name:             "repo.validate",
			Description:      "Run toolchain-aware repository validation (syntax/compile checks).",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"language":{"type":"string"},"build_system":{"type":"string"},"test_framework":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"diagnostics":{"type":"array","items":{"type":"string"}},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{precondWorkspaceSupportedProject},
			Postconditions:   []string{"validation output can be generated"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: "repo.validate"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "repo.build",
			Description:      "Execute project build command with repository-aware defaults.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"extra_args":{"type":"array","items":{"type":"string"}}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 240, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{precondWorkspaceSupportedProject},
			Postconditions:   []string{postcondBuildArtifactsGenerated},
			CostHint:         "high",
			Policy:        newExtraArgsPolicy(catalogBuildAllowedPrefix, catalogTestDeniedPrefix),
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "repo.build"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "repo.test",
			Description:      "Execute repository test suite (preferred alias of repo.run_tests).",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"extra_args":{"type":"array","items":{"type":"string"}}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{precondWorkspaceSupportedProject},
			Postconditions:   []string{postcondTestReportsGenerated},
			CostHint:         "high",
			Policy:        newExtraArgsPolicy(catalogTestAllowedPrefix, catalogTestDeniedPrefix),
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "repo.test"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "repo.run_tests",
			Description:      "Execute repository test suite with repo-aware defaults.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"extra_args":{"type":"array","items":{"type":"string"}}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{precondWorkspaceSupportedProject},
			Postconditions:   []string{postcondTestReportsGenerated},
			CostHint:         "high",
			Policy:        newExtraArgsPolicy(catalogTestAllowedPrefix, catalogTestDeniedPrefix),
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "repo.run_tests"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "repo.test_failures_summary",
			Description:      "Summarize failed tests from provided test output or by executing repository tests.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"output":{"type":"string"},"target":{"type":"string"},"extra_args":{"type":"array","items":{"type":"string"}},"max_failures":{"type":"integer","minimum":1,"maximum":200},"max_diagnostics":{"type":"integer","minimum":1,"maximum":200}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"source":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"failed_count":{"type":"integer"},"failed_tests":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"kind":{"type":"string"},"line":{"type":"string"}}}},"diagnostics":{"type":"array","items":{"type":"string"}},"output_excerpt":{"type":"string"},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace must contain a supported project type when output is omitted"},
			Postconditions:   []string{"test failure summary artifact may be generated"},
			CostHint:         "medium",
			Policy:        newExtraArgsPolicy(catalogTestAllowedPrefix, catalogTestDeniedPrefix),
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "repo.test_failures_summary"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"output":"--- FAIL: TestCreateTodo (0.00s)\nFAIL\tgithub.com/acme/todo\t0.01s"}`),
				mustRawJSON(`{"target":"./...","max_failures":20}`),
			},
		},
		{
			Name:             "repo.stacktrace_summary",
			Description:      "Summarize stacktraces from provided output or by executing repository tests.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"output":{"type":"string"},"target":{"type":"string"},"extra_args":{"type":"array","items":{"type":"string"}},"max_traces":{"type":"integer","minimum":1,"maximum":50},"max_frames":{"type":"integer","minimum":1,"maximum":80}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"source":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"trace_count":{"type":"integer"},"stacktraces":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"message":{"type":"string"},"frames":{"type":"array","items":{"type":"string"}},"frame_count":{"type":"integer"}}}},"diagnostics":{"type":"array","items":{"type":"string"}},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace must contain a supported project type when output is omitted"},
			Postconditions:   []string{"stacktrace summary artifact may be generated"},
			CostHint:         "medium",
			Policy:        newExtraArgsPolicy(catalogTestAllowedPrefix, catalogTestDeniedPrefix),
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "repo.stacktrace_summary"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"output":"panic: runtime error\nmain.main()\n/workspace/repo/main.go:11 +0x29"}`),
				mustRawJSON(`{"target":"./...","max_traces":5,"max_frames":12}`),
			},
		},
		{
			Name:             "repo.changed_files",
			Description:      "Return deterministic changed file metadata from git status/diff or provided status output.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"base_ref":{"type":"string"},"path":{"type":"string"},"max_files":{"type":"integer","minimum":1,"maximum":2000},"include_untracked":{"type":"boolean"},"output":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"source":{"type":"string"},"mode":{"type":"string"},"base_ref":{"type":"string"},"path":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"changed_count":{"type":"integer"},"changed_files":{"type":"array","items":{"type":"object","properties":{"path":{"type":"string"},"status":{"type":"string"},"index_status":{"type":"string"},"worktree_status":{"type":"string"},"staged":{"type":"boolean"},"unstaged":{"type":"boolean"},"untracked":{"type":"boolean"},"deleted":{"type":"boolean"},"renamed_from":{"type":"string"}}}},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 90, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace should be a git repository when output is omitted"},
			Postconditions:   []string{"changed files summary artifact may be generated"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{
					{Field: "path", WorkspaceRelative: true},
				},
				ArgFields: []domain.PolicyArgField{
					{
						Field:          "base_ref",
						MaxLength:      120,
						DenyCharacters: []string{";", "|", "&", "`", "$(", ">", "<", "\n", "\r"},
					},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "repo.changed_files"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","max_files":100}`),
				mustRawJSON(`{"base_ref":"origin/main","path":"internal"}`),
			},
		},
		{
			Name:             "repo.symbol_search",
			Description:      "Search symbols with deterministic file/line/column matches in allowed workspace paths.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"symbol":{"type":"string"},"path":{"type":"string"},"max_results":{"type":"integer","minimum":1,"maximum":2000},"case_sensitive":{"type":"boolean"},"whole_word":{"type":"boolean"},"use_regex":{"type":"boolean"}},"required":["symbol"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"symbol":{"type":"string"},"path":{"type":"string"},"case_sensitive":{"type":"boolean"},"whole_word":{"type":"boolean"},"use_regex":{"type":"boolean"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"matches_count":{"type":"integer"},"truncated":{"type":"boolean"},"matches":{"type":"array","items":{"type":"object","properties":{"path":{"type":"string"},"line":{"type":"integer"},"column":{"type":"integer"},"snippet":{"type":"string"}}}},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 120, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"symbol must be non-empty"},
			Postconditions:   []string{"symbol search artifact may be generated"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{
					{Field: "path", WorkspaceRelative: true},
				},
				ArgFields: []domain.PolicyArgField{
					{
						Field:          "symbol",
						MaxLength:      160,
						DenyCharacters: []string{"\x00", "\n", "\r"},
					},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "repo.symbol_search"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"symbol":"CreateTodo","path":"."}`),
				mustRawJSON(`{"symbol":"^Test.*Todo$","use_regex":true,"path":"."}`),
			},
		},
		{
			Name:             "repo.find_references",
			Description:      "Find symbol references with declaration tagging for refactor-safe reasoning.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"symbol":{"type":"string"},"path":{"type":"string"},"max_references":{"type":"integer","minimum":1,"maximum":2000},"max_results":{"type":"integer","minimum":1,"maximum":2000},"case_sensitive":{"type":"boolean"},"include_declarations":{"type":"boolean"}},"required":["symbol"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"symbol":{"type":"string"},"path":{"type":"string"},"case_sensitive":{"type":"boolean"},"include_declarations":{"type":"boolean"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"references_count":{"type":"integer"},"declaration_count":{"type":"integer"},"truncated":{"type":"boolean"},"references":{"type":"array","items":{"type":"object","properties":{"path":{"type":"string"},"line":{"type":"integer"},"column":{"type":"integer"},"snippet":{"type":"string"},"is_declaration":{"type":"boolean"}}}},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 120, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"symbol must be non-empty"},
			Postconditions:   []string{"references summary artifact may be generated"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{
					{Field: "path", WorkspaceRelative: true},
				},
				ArgFields: []domain.PolicyArgField{
					{
						Field:          "symbol",
						MaxLength:      160,
						DenyCharacters: []string{"\x00", "\n", "\r"},
					},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "repo.find_references"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"symbol":"CreateTodo","path":"."}`),
				mustRawJSON(`{"symbol":"Todo","include_declarations":false}`),
			},
		},
		{
			Name:             "repo.coverage_report",
			Description:      "Run repository tests and return a normalized coverage report.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"coverage_supported":{"type":"boolean"},"coverage_percent":{"type":"number"},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 240, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{precondWorkspaceSupportedProject},
			Postconditions:   []string{"coverage artifacts may be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: "repo.coverage_report"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "repo.static_analysis",
			Description:      "Run project-aware static analysis and lint checks.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"},"diagnostics":{"type":"array","items":{"type":"string"}},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{precondWorkspaceSupportedProject},
			Postconditions:   []string{"analysis diagnostics may be generated"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: "repo.static_analysis"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		{
			Name:             "repo.package",
			Description:      "Package repository output into deployable artifacts.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"artifact_path":{"type":"string"},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{precondWorkspaceSupportedProject},
			Postconditions:   []string{"packaged artifacts may be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: "repo.package"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"."}`),
			},
		},
		{
			Name:             "image.build",
			Description:      "Build container image from workspace Dockerfile using available builder with deterministic fallback.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"context_path":{"type":"string"},"dockerfile_path":{"type":"string"},"tag":{"type":"string"},"push":{"type":"boolean"},"no_cache":{"type":"boolean"},"max_issues":{"type":"integer","minimum":1,"maximum":2000},"include_recommendations":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"builder":{"type":"string"},"simulated":{"type":"boolean"},"context_path":{"type":"string"},"dockerfile_path":{"type":"string"},"tag":{"type":"string"},"image_ref":{"type":"string"},"registry":{"type":"string"},"repository":{"type":"string"},"digest":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"push_command":{"type":"array","items":{"type":"string"}},"push_requested":{"type":"boolean"},"pushed":{"type":"boolean"},"push_skipped_reason":{"type":"string"},"issues_count":{"type":"integer"},"issues":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string"},"severity":{"type":"string"},"line":{"type":"integer"},"message":{"type":"string"},"snippet":{"type":"string"}}}},"recommendations":{"type":"array","items":{"type":"string"}},"truncated":{"type":"boolean"},"exit_code":{"type":"integer"},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 4096},
			Preconditions:    []string{"context_path and dockerfile_path must be inside allowed_paths"},
			Postconditions:   []string{"image build metadata produced; image push may occur when requested"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{
					{Field: "context_path", WorkspaceRelative: true},
					{Field: "dockerfile_path", WorkspaceRelative: true},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "image.build"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"context_path":".","dockerfile_path":"Dockerfile","tag":"ghcr.io/acme/demo:1.0.0","push":false}`),
			},
		},
		{
			Name:             "image.push",
			Description:      "Push an existing container image reference using available builder with deterministic fallback.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"image_ref":{"type":"string"},"max_retries":{"type":"integer","minimum":0,"maximum":5},"strict":{"type":"boolean"},"max_issues":{"type":"integer","minimum":1,"maximum":2000},"include_recommendations":{"type":"boolean"}},"required":["image_ref"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"builder":{"type":"string"},"simulated":{"type":"boolean"},"image_ref":{"type":"string"},"registry":{"type":"string"},"repository":{"type":"string"},"tag":{"type":"string"},"digest":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"attempts":{"type":"integer"},"max_retries":{"type":"integer"},"pushed":{"type":"boolean"},"push_skipped_reason":{"type":"string"},"issues_count":{"type":"integer"},"issues":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string"},"severity":{"type":"string"},"line":{"type":"integer"},"message":{"type":"string"},"snippet":{"type":"string"}}}},"recommendations":{"type":"array","items":{"type":"string"}},"truncated":{"type":"boolean"},"exit_code":{"type":"integer"},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsIrreversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 4096},
			Preconditions:    []string{"image_ref must be a valid image reference"},
			Postconditions:   []string{"image may be pushed to remote registry"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				RegistryFields: []string{"image_ref"},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "image.push"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"image_ref":"ghcr.io/acme/demo:1.0.0@sha256:abc123","max_retries":1}`),
			},
		},
		{
			Name:             "image.inspect",
			Description:      "Inspect Dockerfile or image reference metadata with deterministic security hints.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"context_path":{"type":"string"},"dockerfile_path":{"type":"string"},"image_ref":{"type":"string"},"include_recommendations":{"type":"boolean"},"max_issues":{"type":"integer","minimum":1,"maximum":2000}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"source_type":{"type":"string"},"context_path":{"type":"string"},"dockerfile_path":{"type":"string"},"image_ref":{"type":"string"},"registry":{"type":"string"},"repository":{"type":"string"},"tag":{"type":"string"},"digest":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"base_images":{"type":"array","items":{"type":"string"}},"stages_count":{"type":"integer"},"exposed_ports":{"type":"array","items":{"type":"string"}},"user":{"type":"string"},"entrypoint":{"type":"string"},"cmd":{"type":"string"},"issues_count":{"type":"integer"},"issues":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string"},"severity":{"type":"string"},"line":{"type":"integer"},"message":{"type":"string"},"snippet":{"type":"string"}}}},"recommendations":{"type":"array","items":{"type":"string"}},"truncated":{"type":"boolean"},"exit_code":{"type":"integer"},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 60, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"context_path and dockerfile_path must be inside allowed_paths"},
			Postconditions:   []string{postcondNoRepositoryMutation},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{
					{Field: "context_path", WorkspaceRelative: true},
					{Field: "dockerfile_path", WorkspaceRelative: true},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "image.inspect"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"context_path":".","dockerfile_path":"Dockerfile","max_issues":100}`),
				mustRawJSON(`{"image_ref":"registry.example.com/app:1.2.3@sha256:abc123","include_recommendations":true}`),
			},
		},
		{
			Name:             "artifact.upload",
			Description:      "Read a workspace file and publish it as invocation artifact payload.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"name":{"type":"string"},"content_type":{"type":"string"},"max_bytes":{"type":"integer","minimum":1024,"maximum":10485760}},"required":["path"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"artifact_name":{"type":"string"},"content_type":{"type":"string"},"size_bytes":{"type":"integer"},"sha256":{"type":"string"},"truncated":{"type":"boolean"},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 45, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{precondPathInsideAllowedPaths},
			Postconditions:   []string{"artifact payload attached to invocation"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "artifact.upload"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".workspace-dist/app","name":"app-linux-amd64","content_type":"application/octet-stream"}`),
			},
		},
		{
			Name:             "artifact.download",
			Description:      "Read artifact-like content from workspace and return encoded payload.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"encoding":{"type":"string","enum":["base64","utf8"]},"max_bytes":{"type":"integer","minimum":1024,"maximum":10485760}},"required":["path"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"encoding":{"type":"string"},"content":{"type":"string"},"content_base64":{"type":"string"},"size_bytes":{"type":"integer"},"sha256":{"type":"string"},"truncated":{"type":"boolean"},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 45, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{precondPathInsideAllowedPaths},
			Postconditions:   []string{"artifact payload returned in tool output"},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "artifact.download"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":"coverage-report.txt","encoding":"utf8"}`),
			},
		},
		{
			Name:             "artifact.list",
			Description:      "List candidate artifact files in workspace path.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"recursive":{"type":"boolean"},"pattern":{"type":"string"},"max_entries":{"type":"integer","minimum":1,"maximum":2000}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"recursive":{"type":"boolean"},"pattern":{"type":"string"},"count":{"type":"integer"},"truncated":{"type":"boolean"},"artifacts":{"type":"array","items":{"type":"object","properties":{"path":{"type":"string"},"size_bytes":{"type":"integer"}}}},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 45, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{precondPathInsideAllowedPaths},
			Postconditions:   []string{postcondNoWorkspaceMutation},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "artifact.list"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".workspace-dist","recursive":true,"pattern":"*.tar.gz"}`),
			},
		},
		{
			Name:             "container.ps",
			Description:      "List containers from available runtime (Kubernetes session pods or local podman/docker/nerdctl).",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"all":{"type":"boolean"},"limit":{"type":"integer","minimum":1,"maximum":500},"name_filter":{"type":"string"},"strict":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"runtime":{"type":"string"},"simulated":{"type":"boolean"},"all":{"type":"boolean"},"limit":{"type":"integer"},"name_filter":{"type":"string"},"count":{"type":"integer"},"truncated":{"type":"boolean"},"containers":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string"},"image":{"type":"string"},"name":{"type":"string"},"status":{"type":"string"}}}},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 45, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"container runtime may be required unless simulated fallback is allowed"},
			Postconditions:   []string{postcondNoWorkspaceMutation},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ArgFields: []domain.PolicyArgField{
					{
						Field:          "name_filter",
						MaxLength:      80,
						DenyCharacters: []string{"\n", "\r", " ", ";", "|", "&"},
					},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "container.ps"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"all":true,"limit":50}`),
				mustRawJSON(`{"name_filter":"workspace","strict":false}`),
			},
		},
		{
			Name:             "container.logs",
			Description:      "Read container logs from available runtime (Kubernetes session pods or local podman/docker/nerdctl).",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"container_id":{"type":"string"},"tail_lines":{"type":"integer","minimum":1,"maximum":10000},"since_seconds":{"type":"integer","minimum":0,"maximum":86400},"timestamps":{"type":"boolean"},"strict":{"type":"boolean"},"max_bytes":{"type":"integer","minimum":1024,"maximum":2097152}},"required":["container_id"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"runtime":{"type":"string"},"simulated":{"type":"boolean"},"container_id":{"type":"string"},"tail_lines":{"type":"integer"},"since_seconds":{"type":"integer"},"timestamps":{"type":"boolean"},"bytes":{"type":"integer"},"line_count":{"type":"integer"},"truncated":{"type":"boolean"},"logs":{"type":"string"},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 60, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"container_id must refer to a running or completed container"},
			Postconditions:   []string{postcondNoWorkspaceMutation},
			CostHint:         "low",
			Policy: domain.PolicyMetadata{
				ArgFields: []domain.PolicyArgField{
					{
						Field:          "container_id",
						MaxLength:      128,
						DenyCharacters: []string{"\n", "\r", ";", "|", "&", " ", "\t"},
					},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "container.logs"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"container_id":"abc123","tail_lines":200}`),
			},
		},
		{
			Name:             "container.run",
			Description:      "Start a container using available runtime with bounded args (Kubernetes session pod or local runtime).",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"image_ref":{"type":"string"},"command":{"type":"array","items":{"type":"string"},"maxItems":32},"env":{"type":"object","additionalProperties":{"type":"string"}},"name":{"type":"string"},"detach":{"type":"boolean"},"remove":{"type":"boolean"},"strict":{"type":"boolean"}},"required":["image_ref"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"runtime":{"type":"string"},"simulated":{"type":"boolean"},"image_ref":{"type":"string"},"name":{"type":"string"},"detach":{"type":"boolean"},"remove":{"type":"boolean"},"command":{"type":"array","items":{"type":"string"}},"env":{"type":"array","items":{"type":"string"}},"container_id":{"type":"string"},"status":{"type":"string"},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 90, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"explicit approval required", "image_ref must be valid"},
			Postconditions:   []string{"container may be started in local runtime"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ArgFields: []domain.PolicyArgField{
					{
						Field:          "image_ref",
						MaxLength:      255,
						DenyCharacters: []string{"\n", "\r", " ", "\t", ";", "|", "&"},
					},
					{
						Field:          "name",
						MaxLength:      80,
						DenyCharacters: []string{"\n", "\r", " ", ";", "|", "&"},
					},
					{
						Field:          "command",
						Multi:          true,
						MaxItems:       32,
						MaxLength:      256,
						DenyCharacters: []string{"\n", "\r", ";", "|", "&", "`", "$(", ">", "<"},
					},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "container.run"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"image_ref":"busybox:1.36","command":["echo","hello"],"detach":true}`),
			},
		},
		{
			Name:             "container.exec",
			Description:      "Execute bounded allowlisted command inside a running runtime container (Kubernetes pod or local runtime).",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"container_id":{"type":"string"},"command":{"type":"array","items":{"type":"string"},"maxItems":16},"timeout_seconds":{"type":"integer","minimum":1,"maximum":600},"max_output_bytes":{"type":"integer","minimum":1024,"maximum":2097152},"strict":{"type":"boolean"}},"required":["container_id","command"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"runtime":{"type":"string"},"simulated":{"type":"boolean"},"container_id":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"timeout_seconds":{"type":"integer"},"exit_code":{"type":"integer"},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 90, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"explicit approval required", "command must be allowlisted by runtime guardrails"},
			Postconditions:   []string{"container process may execute command"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				ArgFields: []domain.PolicyArgField{
					{
						Field:          "container_id",
						MaxLength:      128,
						DenyCharacters: []string{"\n", "\r", " ", "\t", ";", "|", "&"},
					},
					{
						Field:          "command",
						Multi:          true,
						MaxItems:       16,
						MaxLength:      256,
						DenyCharacters: []string{"\n", "\r", ";", "|", "&", "`", "$(", ">", "<"},
					},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "container.exec"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"container_id":"abc123","command":["echo","ready"],"timeout_seconds":30}`),
			},
		},
		newK8sReadCapability(
			"k8s.get_pods",
			"List Kubernetes pods in a namespace using the Kubernetes SDK.",
			"k8s.get_pods",
			mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"label_selector":{"type":"string"},"field_selector":{"type":"string"},"max_pods":{"type":"integer","minimum":1,"maximum":500},"include_containers":{"type":"boolean"},"include_labels":{"type":"boolean"}},"required":[]}`),
			mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"label_selector":{"type":"string"},"field_selector":{"type":"string"},"source":{"type":"string"},"count":{"type":"integer"},"truncated":{"type":"boolean"},"include_containers":{"type":"boolean"},"include_labels":{"type":"boolean"},"pods":{"type":"array","items":{"type":"object"}},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			[]json.RawMessage{mustRawJSON(`{"namespace":"swe-ai-fleet","label_selector":"app=workspace","max_pods":50}`)},
		),
		newK8sReadCapability(
			"k8s.get_services",
			"List Kubernetes services in a namespace using the Kubernetes SDK.",
			"k8s.get_services",
			mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"label_selector":{"type":"string"},"field_selector":{"type":"string"},"max_services":{"type":"integer","minimum":1,"maximum":500},"include_labels":{"type":"boolean"}},"required":[]}`),
			mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"label_selector":{"type":"string"},"field_selector":{"type":"string"},"source":{"type":"string"},"count":{"type":"integer"},"truncated":{"type":"boolean"},"include_labels":{"type":"boolean"},"services":{"type":"array","items":{"type":"object"}},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			[]json.RawMessage{mustRawJSON(`{"namespace":"swe-ai-fleet","max_services":50}`)},
		),
		newK8sReadCapability(
			"k8s.get_deployments",
			"List Kubernetes deployments in a namespace using the Kubernetes SDK.",
			"k8s.get_deployments",
			mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"label_selector":{"type":"string"},"field_selector":{"type":"string"},"max_deployments":{"type":"integer","minimum":1,"maximum":500},"include_containers":{"type":"boolean"},"include_labels":{"type":"boolean"}},"required":[]}`),
			mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"label_selector":{"type":"string"},"field_selector":{"type":"string"},"source":{"type":"string"},"count":{"type":"integer"},"truncated":{"type":"boolean"},"include_containers":{"type":"boolean"},"include_labels":{"type":"boolean"},"deployments":{"type":"array","items":{"type":"object"}},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			[]json.RawMessage{mustRawJSON(`{"namespace":"swe-ai-fleet","include_containers":true}`)},
		),
		{
			Name:             "k8s.get_images",
			Description:      "Aggregate container images used by pods in a namespace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"label_selector":{"type":"string"},"field_selector":{"type":"string"},"max_images":{"type":"integer","minimum":1,"maximum":1000},"include_workloads":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"label_selector":{"type":"string"},"field_selector":{"type":"string"},"source":{"type":"string"},"count":{"type":"integer"},"truncated":{"type":"boolean"},"include_workloads":{"type":"boolean"},"images":{"type":"array","items":{"type":"object"}},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeCluster,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 45, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{precondClusterScopeAccess},
			Postconditions:   []string{postcondNoClusterMutation},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				NamespaceFields: []string{"namespace"},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "k8s.get_images"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"namespace":"swe-ai-fleet","max_images":200}`),
			},
		},
		{
			Name:             "k8s.get_logs",
			Description:      "Fetch logs from a Kubernetes pod container.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"pod_name":{"type":"string"},"container":{"type":"string"},"tail_lines":{"type":"integer","minimum":1,"maximum":10000},"since_seconds":{"type":"integer","minimum":0,"maximum":604800},"previous":{"type":"boolean"},"max_bytes":{"type":"integer","minimum":1024,"maximum":2097152}},"required":["pod_name"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"pod_name":{"type":"string"},"container":{"type":"string"},"tail_lines":{"type":"integer"},"since_seconds":{"type":"integer"},"previous":{"type":"boolean"},"source":{"type":"string"},"bytes":{"type":"integer"},"line_count":{"type":"integer"},"truncated":{"type":"boolean"},"logs":{"type":"string"},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeCluster,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{precondClusterScopeAccess},
			Postconditions:   []string{postcondNoClusterMutation},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				NamespaceFields: []string{"namespace"},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "k8s.get_logs"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"namespace":"swe-ai-fleet","pod_name":"workspace-abc123","tail_lines":200}`),
			},
		},
		{
			Name:             "k8s.apply_manifest",
			Description:      "Apply bounded Kubernetes manifests for allowlisted kinds in a namespace.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"manifest":{"type":"string"},"dry_run":{"type":"boolean"},"max_objects":{"type":"integer","minimum":1,"maximum":20}},"required":["manifest"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"dry_run":{"type":"boolean"},"applied_count":{"type":"integer"},"created_count":{"type":"integer"},"updated_count":{"type":"integer"},"resources":{"type":"array","items":{"type":"object","properties":{"api_version":{"type":"string"},"kind":{"type":"string"},"name":{"type":"string"},"namespace":{"type":"string"},"operation":{"type":"string"}}}},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeCluster,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 90, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions: []string{
				precondClusterScopeAccess,
				precondNamespaceAllowlisted,
				"manifest kinds limited to ConfigMap/Deployment/Service",
			},
			Postconditions: []string{"cluster resources may be created or updated"},
			CostHint:       "medium",
			Policy: domain.PolicyMetadata{
				NamespaceFields: []string{"namespace"},
				ArgFields: []domain.PolicyArgField{
					{
						Field:     "manifest",
						MaxLength: k8sApplyManifestMaxBytes,
					},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "k8s.apply_manifest"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"namespace":"swe-ai-fleet","manifest":"apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: sample-config\ndata:\n  key: value\n"}`),
				mustRawJSON(`{"namespace":"swe-ai-fleet","dry_run":true,"manifest":"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: sample-app\nspec:\n  replicas: 0\n  selector:\n    matchLabels:\n      app: sample-app\n  template:\n    metadata:\n      labels:\n        app: sample-app\n    spec:\n      containers:\n      - name: app\n        image: busybox:1.36\n        command: [\"sh\",\"-lc\",\"sleep 3600\"]\n"}`),
			},
		},
		{
			Name:             "k8s.rollout_status",
			Description:      "Wait for a deployment rollout to complete within bounded timeout.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"deployment_name":{"type":"string"},"timeout_seconds":{"type":"integer","minimum":1,"maximum":1800},"poll_interval_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["deployment_name"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"deployment_name":{"type":"string"},"status":{"type":"string"},"duration_ms":{"type":"integer"},"rollout":{"type":"object"},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeCluster,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 120, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions: []string{
				precondClusterScopeAccess,
				precondNamespaceAllowlisted,
				"deployment must exist",
			},
			Postconditions: []string{postcondNoClusterMutation},
			CostHint:       "medium",
			Policy: domain.PolicyMetadata{
				NamespaceFields: []string{"namespace"},
				ArgFields: []domain.PolicyArgField{
					{
						Field:          "deployment_name",
						MaxLength:      253,
						DenyCharacters: []string{" ", "\n", "\r", "/", "\\", ";", "|", "&"},
					},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "k8s.rollout_status"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"namespace":"swe-ai-fleet","deployment_name":"workspace","timeout_seconds":120}`),
			},
		},
		{
			Name:             "k8s.restart_deployment",
			Description:      "Trigger a deployment restart by patching pod-template restart annotation.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"deployment_name":{"type":"string"},"wait_for_rollout":{"type":"boolean"},"timeout_seconds":{"type":"integer","minimum":1,"maximum":1800},"poll_interval_ms":{"type":"integer","minimum":100,"maximum":10000}},"required":["deployment_name"]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"namespace":{"type":"string"},"deployment_name":{"type":"string"},"restarted_at":{"type":"string"},"previous_restarted_at":{"type":"string"},"generation":{"type":"integer"},"observed_generation":{"type":"integer"},"rollout_status":{"type":"string"},"rollout":{"type":"object"},"summary":{"type":"string"},"output":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeCluster,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: true,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions: []string{
				precondClusterScopeAccess,
				precondNamespaceAllowlisted,
				"deployment must exist",
			},
			Postconditions: []string{"deployment rollout may be triggered"},
			CostHint:       "medium",
			Policy: domain.PolicyMetadata{
				NamespaceFields: []string{"namespace"},
				ArgFields: []domain.PolicyArgField{
					{
						Field:          "deployment_name",
						MaxLength:      253,
						DenyCharacters: []string{" ", "\n", "\r", "/", "\\", ";", "|", "&"},
					},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "k8s.restart_deployment"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"namespace":"swe-ai-fleet","deployment_name":"workspace","wait_for_rollout":true,"timeout_seconds":180}`),
			},
		},
		{
			Name:             "security.scan_dependencies",
			Description:      "Collect dependency inventory for the detected project toolchain.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"max_dependencies":{"type":"integer","minimum":1,"maximum":5000}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"dependencies_count":{"type":"integer"},"dependencies":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"version":{"type":"string"},"ecosystem":{"type":"string"},"license":{"type":"string"}}}},"truncated":{"type":"boolean"},"scanner":{"type":"string"},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{precondWorkspaceSupportedProject, precondPathInsideAllowedPaths},
			Postconditions:   []string{"dependency inventory artifact may be generated"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "security.scan_dependencies"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","max_dependencies":500}`),
			},
		},
		{
			Name:             "sbom.generate",
			Description:      "Generate a CycloneDX JSON SBOM from repository dependencies.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"format":{"type":"string","enum":["cyclonedx-json"]},"max_components":{"type":"integer","minimum":1,"maximum":10000}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"format":{"type":"string"},"generator":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"components_count":{"type":"integer"},"components":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"name":{"type":"string"},"version":{"type":"string"},"purl":{"type":"string"}}}},"truncated":{"type":"boolean"},"artifact_name":{"type":"string"},"exit_code":{"type":"integer"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 240, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{precondWorkspaceSupportedProject, precondPathInsideAllowedPaths},
			Postconditions:   []string{"sbom artifact generated"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "sbom.generate"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","format":"cyclonedx-json","max_components":1000}`),
			},
		},
		{
			Name:             "security.scan_secrets",
			Description:      "Scan workspace files for likely hardcoded secrets.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"max_results":{"type":"integer","minimum":1,"maximum":2000}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"findings_count":{"type":"integer"},"findings":{"type":"array","items":{"type":"object","properties":{"path":{"type":"string"},"line":{"type":"integer"},"snippet":{"type":"string"}}}},"truncated":{"type":"boolean"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeWorkspace,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 90, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{precondPathInsideAllowedPaths},
			Postconditions:   []string{postcondNoRepositoryMutation},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "security.scan_secrets"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","max_results":100}`),
			},
		},
		{
			Name:             "security.scan_container",
			Description:      "Scan container image or Dockerfile context for vulnerabilities and misconfigurations.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"image_ref":{"type":"string"},"max_findings":{"type":"integer","minimum":1,"maximum":2000},"severity_threshold":{"type":"string","enum":["low","medium","high","critical"]}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"scanner":{"type":"string"},"target":{"type":"string"},"path":{"type":"string"},"image_ref":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"severity_threshold":{"type":"string"},"findings_count":{"type":"integer"},"findings":{"type":"array","items":{"type":"object","properties":{"kind":{"type":"string"},"id":{"type":"string"},"title":{"type":"string"},"severity":{"type":"string"},"target":{"type":"string"}}}},"severity_counts":{"type":"object"},"truncated":{"type":"boolean"},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 240, MaxRetries: 0, OutputLimitKB: 4096},
			Preconditions:    []string{"path must be inside allowed_paths when provided"},
			Postconditions:   []string{"container scan findings may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "security.scan_container"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","max_findings":200,"severity_threshold":"medium"}`),
				mustRawJSON(`{"image_ref":"registry.example.com/app:1.2.3","severity_threshold":"high"}`),
			},
		},
		{
			Name:             "security.license_check",
			Description:      "Evaluate repository dependency licenses against allow/deny policy.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"path":{"type":"string"},"max_dependencies":{"type":"integer","minimum":1,"maximum":5000},"allowed_licenses":{"type":"array","items":{"type":"string"}},"denied_licenses":{"type":"array","items":{"type":"string"}},"unknown_policy":{"type":"string","enum":["warn","deny"]}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"license_source_command":{"type":"array","items":{"type":"string"}},"dependencies_checked":{"type":"integer"},"allowed_count":{"type":"integer"},"denied_count":{"type":"integer"},"unknown_count":{"type":"integer"},"allowed_licenses":{"type":"array","items":{"type":"string"}},"denied_licenses":{"type":"array","items":{"type":"string"}},"unknown_policy":{"type":"string"},"status":{"type":"string"},"violations":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"version":{"type":"string"},"ecosystem":{"type":"string"},"license":{"type":"string"},"reason":{"type":"string"}}}},"dependencies":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"version":{"type":"string"},"ecosystem":{"type":"string"},"license":{"type":"string"}}}},"truncated":{"type":"boolean"},"exit_code":{"type":"integer"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 4096},
			Preconditions:    []string{precondWorkspaceSupportedProject, precondPathInsideAllowedPaths},
			Postconditions:   []string{"license compliance report may be generated"},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "path", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "security.license_check"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"path":".","allowed_licenses":["MIT","Apache-2.0"],"denied_licenses":["GPL-3.0"],"unknown_policy":"warn"}`),
			},
		},
		{
			Name:             "quality.gate",
			Description:      "Evaluate quality metrics against deterministic acceptance thresholds.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"metrics":{"type":"object","properties":{"coverage_percent":{"type":"number"},"diagnostics_count":{"type":"integer"},"vulnerabilities_count":{"type":"integer"},"denied_licenses_count":{"type":"integer"},"failed_tests_count":{"type":"integer"}}},"min_coverage_percent":{"type":"number","minimum":0,"maximum":100},"max_diagnostics":{"type":"integer","minimum":-1,"maximum":100000},"max_vulnerabilities":{"type":"integer","minimum":-1,"maximum":100000},"max_denied_licenses":{"type":"integer","minimum":-1,"maximum":100000},"max_failed_tests":{"type":"integer","minimum":-1,"maximum":100000}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"status":{"type":"string"},"passed":{"type":"boolean"},"failed_rules_count":{"type":"integer"},"rules":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"operator":{"type":"string"},"expected":{"type":"number"},"actual":{"type":"number"},"passed":{"type":"boolean"},"message":{"type":"string"}}}},"metrics":{"type":"object"},"thresholds":{"type":"object"},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 30, MaxRetries: 0, OutputLimitKB: 256},
			Preconditions:    []string{"quality metrics should be provided for meaningful evaluation"},
			Postconditions:   []string{"quality gate report may be generated"},
			CostHint:         "low",
			Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: "quality.gate"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"metrics":{"coverage_percent":82.5,"diagnostics_count":0,"failed_tests_count":0},"min_coverage_percent":80,"max_diagnostics":0,"max_failed_tests":0}`),
			},
		},
		{
			Name:             "ci.run_pipeline",
			Description:      "Execute a deterministic CI-like sequence: validate, build, test, and optional analysis/coverage.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"include_static_analysis":{"type":"boolean"},"include_coverage":{"type":"boolean"},"include_quality_gate":{"type":"boolean"},"fail_fast":{"type":"boolean"},"quality_gate":{"type":"object","properties":{"min_coverage_percent":{"type":"number","minimum":0,"maximum":100},"max_diagnostics":{"type":"integer","minimum":-1,"maximum":100000},"max_vulnerabilities":{"type":"integer","minimum":-1,"maximum":100000},"max_denied_licenses":{"type":"integer","minimum":-1,"maximum":100000},"max_failed_tests":{"type":"integer","minimum":-1,"maximum":100000}}}},"required":[]}`),
			OutputSchema:     mustRawJSON(`{"type":"object","properties":{"project_type":{"type":"string"},"steps":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"status":{"type":"string"},"command":{"type":"array","items":{"type":"string"}},"exit_code":{"type":"integer"}}}},"quality_metrics":{"type":"object"},"quality_gate":{"type":"object"},"exit_code":{"type":"integer"},"failed_step":{"type":"string"},"summary":{"type":"string"},"output":{"type":"string"}}}`),
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 600, MaxRetries: 0, OutputLimitKB: 4096},
			Preconditions:    []string{precondWorkspaceSupportedProject},
			Postconditions:   []string{"build/test artifacts may be generated", "quality gate report may be generated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: "ci.run_pipeline"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./...","include_static_analysis":true,"include_coverage":true,"include_quality_gate":true,"quality_gate":{"max_failed_tests":0,"max_diagnostics":0},"fail_fast":true}`),
			},
		},
		{
			Name:             "go.mod.tidy",
			Description:      "Run go mod tidy to validate and normalize module dependencies.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"check":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     catalogLangToolOutputSchema,
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{precondWorkspaceGoMod},
			Postconditions:   []string{"go.mod/go.sum may be updated"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: "go.mod.tidy"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"check":true}`),
			},
		},
		{
			Name:             "go.generate",
			Description:      "Run go generate for a package target.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     catalogLangToolOutputSchema,
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{precondWorkspaceGoMod},
			Postconditions:   []string{"generated files may be updated"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: "go.generate"},
			Examples: []json.RawMessage{
				mustRawJSON(`{"target":"./..."}`),
			},
		},
		newGoCapability(
			"go.build",
			"Compile Go package with restricted build flags and optional output binary name.",
			"go.build",
			mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"ldflags":{"type":"string"},"output_name":{"type":"string"},"race":{"type":"boolean"}},"required":[]}`),
			[]string{postcondBuildArtifactsGenerated},
			[]json.RawMessage{mustRawJSON(`{"target":"./cmd/app","output_name":"app","ldflags":"-s -w","race":false}`)},
		),
		newGoCapability(
			"go.test",
			"Run Go tests with optional coverage and run-pattern filter.",
			"go.test",
			mustRawJSON(`{"type":"object","properties":{"package":{"type":"string"},"coverage":{"type":"boolean"},"run_pattern":{"type":"string"}},"required":[]}`),
			[]string{postcondTestReportsGenerated},
			[]json.RawMessage{mustRawJSON(`{"package":"./...","coverage":true}`)},
		),
		newRustCapability(
			"rust.build",
			"Compile Rust project/package with cargo build.",
			"rust.build",
			mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"release":{"type":"boolean"}},"required":[]}`),
			[]string{"target artifacts may be generated"},
			"high", 300,
		),
		newRustCapability(
			"rust.test",
			"Run Rust tests using cargo test.",
			"rust.test",
			mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			[]string{postcondTestOutputGenerated},
			"high", 300,
		),
		newRustCapability(
			"rust.clippy",
			"Run clippy lints for Rust project.",
			"rust.clippy",
			mustRawJSON(`{"type":"object","properties":{"deny_warnings":{"type":"boolean"}},"required":[]}`),
			[]string{"lint diagnostics may be generated"},
			"high", 300,
		),
		{
			Name:             "rust.format",
			Description:      "Run rustfmt in check or write mode.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"check":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     catalogLangToolOutputSchema,
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{precondWorkspaceCargoToml},
			Postconditions:   []string{"formatting may be updated"},
			CostHint:         "medium",
			Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: "rust.format"},
		},
		{
			Name:             "node.install",
			Description:      "Install Node dependencies using npm ci/install.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"use_ci":{"type":"boolean"},"ignore_scripts":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     catalogLangToolOutputSchema,
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{precondWorkspacePackageJSON},
			Postconditions:   []string{"node_modules may be updated"},
			CostHint:         "high",
			Observability:    domain.Observability{TraceName: catalogTraceName, SpanName: "node.install"},
		},
		newNodeCapability(
			"node.build",
			"Run Node/TypeScript build script with npm.",
			"node.build",
			mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			[]string{postcondBuildArtifactsGenerated},
			"high", 300, 2048,
		),
		newNodeCapability(
			"node.test",
			"Run Node test script with npm.",
			"node.test",
			mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			[]string{postcondTestOutputGenerated},
			"high", 300, 2048,
		),
		newNodeCapability(
			"node.lint",
			"Run Node lint script with npm.",
			"node.lint",
			mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			[]string{"lint diagnostics may be generated"},
			"high", 240, 2048,
		),
		newNodeCapability(
			"node.typecheck",
			"Run TypeScript typecheck script with npm.",
			"node.typecheck",
			mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			[]string{"typecheck diagnostics may be generated"},
			"high", 240, 2048,
		),
		{
			Name:             "python.install_deps",
			Description:      "Install Python dependencies in an isolated venv.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"use_venv":{"type":"boolean"},"requirements_file":{"type":"string"},"constraints_file":{"type":"string"}},"required":[]}`),
			OutputSchema:     catalogLangToolOutputSchema,
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain Python dependency manifest"},
			Postconditions:   []string{"venv and site-packages may be updated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{
					{Field: "requirements_file", WorkspaceRelative: true},
					{Field: "constraints_file", WorkspaceRelative: true},
				},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "python.install_deps"},
		},
		{
			Name:             "python.validate",
			Description:      "Validate Python syntax/bytecode compilation.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"}},"required":[]}`),
			OutputSchema:     catalogLangToolOutputSchema,
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsNone,
			RiskLevel:        domain.RiskLow,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyGuaranteed,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace must contain Python sources"},
			Postconditions:   []string{postcondNoRepositoryMutation},
			CostHint:         "medium",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "target", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "python.validate"},
		},
		{
			Name:             "python.test",
			Description:      "Run Python tests with constrained pytest options.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"target":{"type":"string"},"run_pattern":{"type":"string"},"max_fail":{"type":"integer","minimum":1,"maximum":20}},"required":[]}`),
			OutputSchema:     catalogLangToolOutputSchema,
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 300, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain pytest-compatible tests"},
			Postconditions:   []string{postcondTestOutputGenerated},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "target", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "python.test"},
		},
		{
			Name:             "c.build",
			Description:      "Compile C source files with constrained compiler options.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"source":{"type":"string"},"output_name":{"type":"string"},"standard":{"type":"string","enum":["c89","c99","c11","c17","c23"]}},"required":[]}`),
			OutputSchema:     catalogLangToolOutputSchema,
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 1024},
			Preconditions:    []string{"workspace must contain C source files"},
			Postconditions:   []string{"compiled binary may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "source", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "c.build"},
		},
		{
			Name:             "c.test",
			Description:      "Compile and optionally run C test source files.",
			InputSchema:      mustRawJSON(`{"type":"object","properties":{"source":{"type":"string"},"output_name":{"type":"string"},"standard":{"type":"string","enum":["c89","c99","c11","c17","c23"]},"run":{"type":"boolean"}},"required":[]}`),
			OutputSchema:     catalogLangToolOutputSchema,
			Scope:            domain.ScopeRepo,
			SideEffects:      domain.SideEffectsReversible,
			RiskLevel:        domain.RiskMedium,
			RequiresApproval: false,
			Idempotency:      domain.IdempotencyBestEffort,
			Constraints:      domain.Constraints{TimeoutSeconds: 180, MaxRetries: 0, OutputLimitKB: 2048},
			Preconditions:    []string{"workspace must contain C test source files"},
			Postconditions:   []string{"test binary/output may be generated"},
			CostHint:         "high",
			Policy: domain.PolicyMetadata{
				PathFields: []domain.PolicyPathField{{Field: "source", WorkspaceRelative: true}},
			},
			Observability: domain.Observability{TraceName: catalogTraceName, SpanName: "c.test"},
		},
	}
}

func mustRawJSON(input string) json.RawMessage {
	return json.RawMessage(input)
}
