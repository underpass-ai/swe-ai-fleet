# üéØ Arquitectura Simplificada: Containers sin Ray

## Idea

En lugar de usar Ray (complejo), usar **containers simples** que se comuniquen v√≠a NATS.

---

## üèóÔ∏è Arquitectura Propuesta

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Kubernetes / Podman                          ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ             Orchestrator Service                        ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ                                                          ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  Deliberate(task) ‚îÄ‚îÄ> Publica NATS:                    ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ                       "agent.task.assigned"             ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ                       {task_id, description, role}      ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ                                                          ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  GetDeliberationResult(task_id) ‚îÄ‚îÄ> Query Redis/NATS   ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                           ‚îÇ                                     ‚îÇ
‚îÇ                           ‚ñº                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ                   NATS JetStream                        ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ                                                          ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  Subjects:                                               ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - agent.task.assigned                                   ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - agent.response.completed                              ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                           ‚îÇ                                     ‚îÇ
‚îÇ                           ‚ñº                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ         vLLM Agent Workers (Deployment/StatefulSet)     ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ                                                          ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  Replicas: 3 (o m√°s seg√∫n carga)                       ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ                                                          ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  Pod 1: ‚îÄ‚îÄ‚îê                                             ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  Pod 2: ‚îÄ‚îÄ‚îº‚îÄ‚îÄ> Subscribe NATS: agent.task.assigned     ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  Pod 3: ‚îÄ‚îÄ‚îò    ‚îî‚îÄ> Procesa task                        ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ                    ‚îî‚îÄ> Llama vLLM                       ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ                    ‚îî‚îÄ> Publica NATS: agent.response.*  ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                           ‚îÇ                                     ‚îÇ
‚îÇ                           ‚ñº                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ                 vLLM Server (GPU)                       ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ                                                          ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  HTTP API: /v1/chat/completions                        ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  Model: Qwen3-0.6B                                      ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  GPU: 1x RTX 3090                                       ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üîÑ Flujo Simplificado

### 1. Cliente ‚Üí Orchestrator
```python
stub.Deliberate(task="Write factorial", role="DEV", num_agents=3)
```

### 2. Orchestrator ‚Üí NATS (x3 mensajes)
```json
// Message 1
{
  "task_id": "task-123",
  "agent_id": "agent-dev-001",
  "description": "Write factorial",
  "role": "DEV",
  "constraints": {...},
  "diversity": false
}

// Message 2  
{
  "task_id": "task-123",
  "agent_id": "agent-dev-002",
  "description": "Write factorial",
  "role": "DEV",
  "constraints": {...},
  "diversity": true
}

// Message 3
{...}
```

**Subject**: `agent.task.assigned.DEV` (queue group por rol)

### 3. vLLM Agent Workers ‚Üí Consume NATS
```
Worker Pod 1 ‚îÄ‚îÄ> Recibe agent-dev-001 task
               ‚îî‚îÄ> Llama vLLM API
               ‚îî‚îÄ> Publica: agent.response.completed

Worker Pod 2 ‚îÄ‚îÄ> Recibe agent-dev-002 task
               ‚îî‚îÄ> Llama vLLM API  
               ‚îî‚îÄ> Publica: agent.response.completed

Worker Pod 3 ‚îÄ‚îÄ> Recibe agent-dev-003 task
               ‚îî‚îÄ> Llama vLLM API
               ‚îî‚îÄ> Publica: agent.response.completed
```

### 4. DeliberationResultCollector ‚Üí Acumula
```
Escucha: agent.response.completed
Acumula por task_id
Cuando 3/3 ‚îÄ‚îÄ> Publica: deliberation.completed
```

### 5. Cliente ‚Üí Consulta
```python
result = stub.GetDeliberationResult(task_id="task-123")
# Retorna las 3 propuestas
```

---

## üí° Ventajas vs Ray

### Simplicidad
- ‚úÖ No necesita Ray cluster
- ‚úÖ Solo containers simples
- ‚úÖ F√°cil de debuggear
- ‚úÖ Menos moving parts

### Escalabilidad
- ‚úÖ Kubernetes Deployment (auto-scaling)
- ‚úÖ HPA basado en queue depth
- ‚úÖ Multiple pods procesando en paralelo

### Compatibilidad
- ‚úÖ Funciona en E2E containers
- ‚úÖ Funciona en K8s
- ‚úÖ Funciona en Podman
- ‚úÖ No requiere Ray operators

---

## üõ†Ô∏è Implementaci√≥n

### vLLM Agent Worker Container

```python
# src/swe_ai_fleet/orchestrator/workers/vllm_agent_worker.py

import asyncio
import json
import nats
import aiohttp


class VLLMAgentWorker:
    """
    Simple worker que consume tasks de NATS y ejecuta con vLLM.
    """
    
    def __init__(self, vllm_url, nats_url, role):
        self.vllm_url = vllm_url
        self.nats_url = nats_url
        self.role = role
    
    async def run(self):
        """Main loop: consume NATS, execute, publish."""
        nc = await nats.connect(self.nats_url)
        js = nc.jetstream()
        
        # Subscribe to tasks for this role (queue group)
        await js.subscribe(
            subject=f"agent.task.assigned.{self.role}",
            queue=f"agent-workers-{self.role}",  # Load balancing
            cb=self._handle_task
        )
        
        print(f"‚úÖ Worker started for role {self.role}")
        
        # Keep running
        await asyncio.Event().wait()
    
    async def _handle_task(self, msg):
        """Process a task."""
        data = json.loads(msg.data)
        task_id = data["task_id"]
        agent_id = data["agent_id"]
        description = data["description"]
        
        print(f"[{agent_id}] Processing task {task_id}")
        
        # Call vLLM
        proposal = await self._call_vllm(description, data.get("constraints", {}))
        
        # Publish result
        result = {
            "task_id": task_id,
            "agent_id": agent_id,
            "role": self.role,
            "proposal": proposal,
            "status": "completed"
        }
        
        await msg.ack()
        
        nc = await nats.connect(self.nats_url)
        js = nc.jetstream()
        await js.publish("agent.response.completed", json.dumps(result).encode())
        
        print(f"[{agent_id}] ‚úÖ Completed")
    
    async def _call_vllm(self, task, constraints):
        """Call vLLM API."""
        async with aiohttp.ClientSession() as session:
            payload = {
                "model": "Qwen/Qwen3-0.6B",
                "messages": [
                    {"role": "system", "content": f"You are a {self.role} expert"},
                    {"role": "user", "content": task}
                ],
                "temperature": 0.7,
                "max_tokens": 2048
            }
            
            async with session.post(
                f"{self.vllm_url}/v1/chat/completions",
                json=payload
            ) as response:
                data = await response.json()
                return {
                    "content": data["choices"][0]["message"]["content"],
                    "author_id": self.agent_id,
                    "author_role": self.role
                }


if __name__ == "__main__":
    import os
    
    worker = VLLMAgentWorker(
        vllm_url=os.getenv("VLLM_URL", "http://vllm-server-service:8000"),
        nats_url=os.getenv("NATS_URL", "nats://nats:4222"),
        role=os.getenv("AGENT_ROLE", "DEV")
    )
    
    asyncio.run(worker.run())
```

### Kubernetes Deployment

```yaml
# deploy/k8s/vllm-agent-workers.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vllm-agent-dev
  namespace: swe-ai-fleet
spec:
  replicas: 3  # 3 workers para role DEV
  selector:
    matchLabels:
      app: vllm-agent
      role: dev
  template:
    metadata:
      labels:
        app: vllm-agent
        role: dev
    spec:
      containers:
      - name: agent-worker
        image: registry.underpassai.com/swe-fleet/vllm-agent-worker:v0.1.0
        env:
        - name: AGENT_ROLE
          value: "DEV"
        - name: VLLM_URL
          value: "http://vllm-server-service:8000"
        - name: NATS_URL
          value: "nats://nats:4222"
        resources:
          requests:
            cpu: "500m"
            memory: "512Mi"
          limits:
            cpu: "1"
            memory: "1Gi"

---
# Similar deployments para QA, ARCHITECT, DEVOPS, DATA
```

### Modificaci√≥n en Orchestrator

```python
# En server.py, m√©todo Deliberate:

def Deliberate(self, request, context):
    """Env√≠a tasks a NATS para que agents procesen."""
    task_id = str(uuid.uuid4())
    
    # Publicar N tasks a NATS (uno por agent)
    for i in range(request.num_agents or 3):
        agent_id = f"agent-{request.role.lower()}-{i+1:03d}"
        
        task_message = {
            "task_id": task_id,
            "agent_id": agent_id,
            "description": request.task_description,
            "role": request.role,
            "constraints": self._proto_to_dict(request.constraints),
            "diversity": (i > 0),
            "num_agents": request.num_agents or 3
        }
        
        # Publish a NATS
        await self.js.publish(
            subject=f"agent.task.assigned.{request.role}",
            payload=json.dumps(task_message).encode()
        )
    
    # Retornar inmediatamente
    return orchestrator_pb2.DeliberateResponse(
        task_id=task_id,
        # ... resto de campos
    )
```

---

## ‚úÖ Ventajas de esta Arquitectura

### 1. Simplicidad
- ‚ùå No Ray (no operators, no complejidad)
- ‚úÖ Solo NATS + containers
- ‚úÖ F√°cil de entender y debuggear

### 2. Escalabilidad
- ‚úÖ Kubernetes HPA (auto-scaling)
- ‚úÖ Queue depth metrics para scaling
- ‚úÖ Multiple pods en paralelo

### 3. Fault Tolerance
- ‚úÖ K8s restart policy
- ‚úÖ NATS redelivery si falla
- ‚úÖ Liveness/readiness probes

### 4. Testing
- ‚úÖ Funciona en E2E containers
- ‚úÖ Funciona en K8s
- ‚úÖ F√°cil local testing

---

## üöÄ Pr√≥ximos Pasos

¬øQuieres que implemente esta arquitectura simplificada? Ser√≠a:

1. **Crear `VLLMAgentWorker`** (container simple NATS consumer)
2. **Dockerfile** para el worker
3. **Deployment K8s** para workers (uno por rol)
4. **Modificar Orchestrator** para publicar tasks a NATS
5. **Mantener DeliberationResultCollector** (ya funciona)

**Ventajas**:
- ‚úÖ M√°s simple que Ray
- ‚úÖ Funciona en E2E containers
- ‚úÖ F√°cil de escalar en K8s
- ‚úÖ Compatible con Podman/CRI-O

¬øVamos con esta arquitectura? üöÄ

